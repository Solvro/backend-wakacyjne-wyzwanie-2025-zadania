import { AST_NODE_TYPES, ESLintUtils, } from "@typescript-eslint/utils";
import { isNullableType } from "@typescript-eslint/type-utils";
import { getPropertiesDefinitions } from "../../utils/ast.js";
import { createRule } from "../../utils/createRule.js";
import { typedTokenHelpers } from "../../utils/typedTokenHelpers.js";
const rule = createRule({
    name: "all-properties-have-explicit-defined",
    meta: {
        docs: {
            description: "Enforce all properties have an explicit defined status decorator",
        },
        messages: {
            "missing-is-defined-decorator": "Non-optional properties must have a decorator that checks the value is defined (for example: @IsDefined())",
            "missing-is-optional-decorator": "Optional properties must have @IsOptional() or @ValidateIf() decorator",
            "conflicting-defined-decorators-defined-optional": "Properties can have @IsDefined() or @IsOptional() but not both",
            "conflicting-defined-decorators-defined-validate-if": "Properties can have @IsDefined() or @ValidateIf() but not both",
            "conflicting-defined-decorators-optional-validate-if": "Properties can have @IsOptional() or @ValidateIf() but not both",
            "conflicting-defined-decorators-all": "Properties can have one of @IsDefined() or @IsOptional() or @ValidateIf()",
        },
        type: "problem",
        schema: [],
    },
    defaultOptions: [],
    create: function (context) {
        const service = ESLintUtils.getParserServices(context);
        const checker = service.program.getTypeChecker();
        return {
            ClassDeclaration(node) {
                const propertyDefinitionsWithDecoratorsStatus = [];
                let withDecoratorCount = 0;
                const propertyDefinitions = getPropertiesDefinitions(node);
                // for each property in the class
                for (const propertyDefinition of propertyDefinitions) {
                    // check for the optional or defined decorators, or any class-validator decorator
                    const decoratorsStatus = getDecoratorsStatus(propertyDefinition);
                    propertyDefinitionsWithDecoratorsStatus.push([
                        propertyDefinition,
                        decoratorsStatus,
                    ]);
                    // It doesn't make sense to have all three decorators on the same property
                    if (decoratorsStatus.hasIsDefinedDecorator &&
                        decoratorsStatus.hasIsOptionalDecorator &&
                        decoratorsStatus.hasValidateIfDecorator) {
                        context.report({
                            node: propertyDefinition,
                            messageId: "conflicting-defined-decorators-all",
                        });
                    }
                    else if (decoratorsStatus.hasIsDefinedDecorator &&
                        decoratorsStatus.hasIsOptionalDecorator) {
                        context.report({
                            node: propertyDefinition,
                            messageId: "conflicting-defined-decorators-defined-optional",
                        });
                    }
                    else if (decoratorsStatus.hasIsDefinedDecorator &&
                        decoratorsStatus.hasValidateIfDecorator) {
                        context.report({
                            node: propertyDefinition,
                            messageId: "conflicting-defined-decorators-defined-validate-if",
                        });
                    }
                    else if (decoratorsStatus.hasIsOptionalDecorator &&
                        decoratorsStatus.hasValidateIfDecorator) {
                        context.report({
                            node: propertyDefinition,
                            messageId: "conflicting-defined-decorators-optional-validate-if",
                        });
                    }
                    else if (decoratorsStatus.hasIsDefinedDecorator ||
                        decoratorsStatus.hasTypeCheckingDecorator ||
                        decoratorsStatus.hasIsOptionalDecorator ||
                        decoratorsStatus.hasValidateIfDecorator) {
                        withDecoratorCount++;
                    }
                }
                if (withDecoratorCount > 0) {
                    for (const [propertyDefinition, decoratorsStatus,] of propertyDefinitionsWithDecoratorsStatus) {
                        // if there's no type available we can't check if it's optional
                        if (!propertyDefinition.typeAnnotation) {
                            continue;
                        }
                        // get the type of the property
                        const type = getType(propertyDefinition.typeAnnotation.typeAnnotation, service, checker);
                        // if the type is nullable, it should be optional
                        if (propertyDefinition.optional ||
                            isNullableType(type)) {
                            if (!decoratorsStatus.hasIsOptionalDecorator &&
                                !decoratorsStatus.hasValidateIfDecorator) {
                                context.report({
                                    node: propertyDefinition,
                                    messageId: "missing-is-optional-decorator",
                                });
                            }
                        }
                        else {
                            if (!decoratorsStatus.hasIsDefinedDecorator &&
                                !decoratorsStatus.hasTypeCheckingDecorator) {
                                context.report({
                                    node: propertyDefinition,
                                    messageId: "missing-is-defined-decorator",
                                });
                            }
                        }
                    }
                }
            },
        };
    },
});
export default rule;
function getType(typeNode, service, checker) {
    const tsNode = service.esTreeNodeToTSNodeMap.get(typeNode);
    const type = checker.getTypeAtLocation(tsNode);
    return type;
}
function getDecoratorsStatus(propertyDefinition) {
    let hasIsDefinedDecorator = false;
    let hasTypeCheckingDecorator = false;
    let hasIsOptionalDecorator = false;
    let hasValidateIfDecorator = false;
    const program = typedTokenHelpers.getRootProgram(propertyDefinition);
    if (propertyDefinition.decorators) {
        for (const decorator of propertyDefinition.decorators) {
            if (decorator.expression.type === AST_NODE_TYPES.CallExpression &&
                decorator.expression.callee.type === AST_NODE_TYPES.Identifier) {
                // if this is not a class-validator decorator, skip it (this avoids name conflicts with decorators from other libraries)
                if (!typedTokenHelpers.decoratorIsClassValidatorDecorator(program, decorator)) {
                    continue;
                }
                // We care if the decorator is a validation decorator like IsString etc for checks later
                if (decorator.expression.callee.name !== "IsDefined" &&
                    decorator.expression.callee.name !== "IsOptional" &&
                    decorator.expression.callee.name !== "ValidateIf") {
                    hasTypeCheckingDecorator = true;
                }
                // otherwise check if it is isDefined or isOptional, we will use this later
                if (decorator.expression.callee.name === "IsDefined") {
                    hasIsDefinedDecorator = true;
                }
                if (decorator.expression.callee.name === "IsOptional") {
                    hasIsOptionalDecorator = true;
                }
                if (decorator.expression.callee.name === "ValidateIf") {
                    hasValidateIfDecorator = true;
                }
            }
        }
    }
    return {
        hasIsDefinedDecorator,
        hasTypeCheckingDecorator,
        hasIsOptionalDecorator,
        hasValidateIfDecorator,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWxsUHJvcGVydGllc0hhdmVFeHBsaWNpdERlZmluZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcnVsZXMvYWxsUHJvcGVydGllc0hhdmVFeHBsaWNpdERlZmluZWQvYWxsUHJvcGVydGllc0hhdmVFeHBsaWNpdERlZmluZWQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILGNBQWMsRUFFZCxXQUFXLEdBRWQsTUFBTSwwQkFBMEIsQ0FBQztBQUNsQyxPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0sK0JBQStCLENBQUM7QUFDN0QsT0FBTyxFQUFDLHdCQUF3QixFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDNUQsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBRXJELE9BQU8sRUFBQyxpQkFBaUIsRUFBQyxNQUFNLGtDQUFrQyxDQUFDO0FBRW5FLE1BQU0sSUFBSSxHQUFHLFVBQVUsQ0FRckI7SUFDRSxJQUFJLEVBQUUsc0NBQXNDO0lBQzVDLElBQUksRUFBRTtRQUNGLElBQUksRUFBRTtZQUNGLFdBQVcsRUFDUCxrRUFBa0U7U0FDekU7UUFDRCxRQUFRLEVBQUU7WUFDTiw4QkFBOEIsRUFDMUIsNEdBQTRHO1lBQ2hILCtCQUErQixFQUMzQix3RUFBd0U7WUFDNUUsaURBQWlELEVBQzdDLGdFQUFnRTtZQUNwRSxvREFBb0QsRUFDaEQsZ0VBQWdFO1lBQ3BFLHFEQUFxRCxFQUNqRCxpRUFBaUU7WUFDckUsb0NBQW9DLEVBQ2hDLDJFQUEyRTtTQUNsRjtRQUNELElBQUksRUFBRSxTQUFTO1FBQ2YsTUFBTSxFQUFFLEVBQUU7S0FDYjtJQUNELGNBQWMsRUFBRSxFQUFFO0lBQ2xCLE1BQU0sRUFBRSxVQUFVLE9BQU87UUFDckIsTUFBTSxPQUFPLEdBQUcsV0FBVyxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXZELE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFP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