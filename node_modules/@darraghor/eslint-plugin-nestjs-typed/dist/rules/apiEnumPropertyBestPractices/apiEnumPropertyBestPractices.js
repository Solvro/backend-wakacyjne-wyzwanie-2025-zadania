import { ESLintUtils } from "@typescript-eslint/utils";
import { createRule } from "../../utils/createRule.js";
import { typedTokenHelpers } from "../../utils/typedTokenHelpers.js";
import { EnumTestResultModel } from "./enumTestResultModel.js";
const noChangesRequiredResult = new EnumTestResultModel({
    needsEnumAdded: false,
    needsEnumNameAdded: false,
    needsEnumNameToMatchEnumType: false,
    needsTypeRemoved: false,
});
export const hasEnumSpecifiedCorrectly = (node, isEnumType) => {
    // is this an enum
    if (!isEnumType) {
        return noChangesRequiredResult;
    }
    // is this decorated with api documentation
    const decorators = typedTokenHelpers.getDecoratorsNamed(node, ["ApiPropertyOptional", "ApiProperty"]);
    if (decorators.length === 0) {
        return noChangesRequiredResult;
    }
    // check if there is an enum property in the provided options (enums should specify the enum property)
    const firstArgument = decorators[0].expression
        .arguments[0];
    if (!firstArgument) {
        return new EnumTestResultModel({
            needsEnumAdded: true,
            needsEnumNameAdded: true,
            needsEnumNameToMatchEnumType: false,
            needsTypeRemoved: false,
        });
    }
    const enumProperty = firstArgument.properties.find((p) => p.key.name ===
        "enum");
    // check if there is a type: property in the provided options (enums shouldn't specify type)
    const hasTypeProperty = firstArgument.properties.find((p) => p.key.name ===
        "type") !== undefined;
    // check if there is an enumName: property in the provided options (enums should specify a name)
    const enumNameProperty = firstArgument.properties.find((p) => p.key.name ===
        "enumName");
    return new EnumTestResultModel({
        needsEnumAdded: enumProperty === undefined,
        needsEnumNameAdded: enumNameProperty === undefined,
        needsEnumNameToMatchEnumType: needsEnumNameMatchingEnumType(enumNameProperty, enumProperty),
        needsTypeRemoved: hasTypeProperty,
    });
};
export const needsEnumNameMatchingEnumType = (enumNameProperty, enumProperty) => {
    // if enum props aren't specified we don't care about this scenario
    if (enumNameProperty === undefined || enumProperty === undefined) {
        return false;
    }
    const isEnumNameMatchingEnumType = enumNameProperty.value.value ===
        enumProperty.value?.name;
    return !isEnumNameMatchingEnumType;
};
const rule = createRule({
    name: "api-enum-property-best-practices",
    meta: {
        docs: {
            description: "Enums should use the best practices for api documentation",
        },
        messages: {
            needsEnumNameAdded: `Properties with enum should also specify an enumName property to keep generated models clean`,
            needsTypeRemoved: `Properties with enum should not specify a type property`,
            enumNameShouldMatchType: `The enumName should match the enum type provided`,
        },
        schema: [],
        hasSuggestions: false,
        type: "suggestion",
    },
    defaultOptions: [],
    create(context) {
        //const globalScope = context.getScope();
        const parserServices = ESLintUtils.getParserServices(context);
        const typeChecker = parserServices.program.getTypeChecker();
        return {
            PropertyDefinition(node) {
                const mappedNode = parserServices.esTreeNodeToTSNodeMap.get(node);
                const objectType = typeChecker.getTypeAtLocation(mappedNode);
                const isEnumType = typedTokenHelpers.isEnumType(objectType);
                const result = hasEnumSpecifiedCorrectly(node, isEnumType);
                if (result.needsEnumNameAdded) {
                    context.report({
                        node: node,
                        messageId: "needsEnumNameAdded",
                    });
                }
                if (result.needsTypeRemoved) {
                    context.report({
                        node: node,
                        messageId: "needsTypeRemoved",
                    });
                }
                if (result.needsEnumNameToMatchEnumType) {
                    context.report({
                        node: node,
                        messageId: "enumNameShouldMatchType",
                    });
                }
            },
        };
    },
});
export default rule;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpRW51bVByb3BlcnR5QmVzdFByYWN0aWNlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ydWxlcy9hcGlFbnVtUHJvcGVydHlCZXN0UHJhY3RpY2VzL2FwaUVudW1Qcm9wZXJ0eUJlc3RQcmFjdGljZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFdBQVcsRUFBVyxNQUFNLDBCQUEwQixDQUFDO0FBQy9ELE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQztBQUNyRCxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxrQ0FBa0MsQ0FBQztBQUNuRSxPQUFPLEVBQUMsbUJBQW1CLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUU3RCxNQUFNLHVCQUF1QixHQUFHLElBQUksbUJBQW1CLENBQUM7SUFDcEQsY0FBYyxFQUFFLEtBQUs7SUFDckIsa0JBQWtCLEVBQUUsS0FBSztJQUN6Qiw0QkFBNEIsRUFBRSxLQUFLO0lBQ25DLGdCQUFnQixFQUFFLEtBQUs7Q0FDMUIsQ0FBQyxDQUFDO0FBRUgsTUFBTSxDQUFDLE1BQU0seUJBQXlCLEdBQUcsQ0FDckMsSUFBbUIsRUFDbkIsVUFBbUIsRUFDQSxFQUFFO0lBQ3JCLGtCQUFrQjtJQUNsQixJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDZCxPQUFPLHVCQUF1QixDQUFDO0lBQ25DLENBQUM7SUFFRCwyQ0FBMkM7SUFDM0MsTUFBTSxVQUFVLEdBQUcsaUJBQWlCLENBQUMsa0JBQWtCLENBQ25ELElBQW1DLEVBQ25DLENBQUMscUJBQXFCLEVBQUUsYUFBYSxDQUFDLENBQ3pDLENBQUM7SUFFRixJQUFJLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7UUFDMUIsT0FBTyx1QkFBdUIsQ0FBQztJQUNuQyxDQUFDO0lBRUQsc0dBQXNHO0lBQ3RHLE1BQU0sYUFBYSxHQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFz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