import { createRule } from "../../utils/createRule.js";
import { typedTokenHelpers } from "../../utils/typedTokenHelpers.js";
export const shouldUseRequiredDecorator = (node) => {
    const hasOptionalDecorator = typedTokenHelpers.nodeHasDecoratorsNamed(node, ["ApiPropertyOptional"]);
    const isOptionalPropertyValue = typedTokenHelpers.isOptionalPropertyValue(node);
    return hasOptionalDecorator && !isOptionalPropertyValue;
};
export const shouldUseOptionalDecorator = (node) => {
    const hasRequiredDecorator = typedTokenHelpers.nodeHasDecoratorsNamed(node, ["ApiProperty"]);
    const isOptionalPropertyValue = typedTokenHelpers.isOptionalPropertyValue(node);
    return hasRequiredDecorator && isOptionalPropertyValue;
};
const rule = createRule({
    name: "api-property-matches-property-optionality",
    meta: {
        docs: {
            description: "Properties should have correct @ApiProperty decorators",
        },
        messages: {
            shouldUseOptionalDecorator: `Property marked as optional should use @ApiPropertyOptional decorator`,
            shouldUseRequiredDecorator: `Property marked as required should use @ApiProperty decorator`,
        },
        schema: [],
        hasSuggestions: false,
        type: "suggestion",
    },
    defaultOptions: [],
    create(context) {
        return {
            PropertyDefinition(node) {
                if (shouldUseOptionalDecorator(node)) {
                    context.report({
                        node: node,
                        messageId: "shouldUseOptionalDecorator",
                    });
                }
                if (shouldUseRequiredDecorator(node)) {
                    context.report({
                        node: node,
                        messageId: "shouldUseRequiredDecorator",
                    });
                }
            },
        };
    },
});
export default rule;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpUHJvcGVydHlNYXRjaGVzUHJvcGVydHlPcHRpb25hbGl0eS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ydWxlcy9hcGlQcm9wZXJ0eU1hdGNoZXNQcm9wZXJ0eU9wdGlvbmFsaXR5L2FwaVByb3BlcnR5TWF0Y2hlc1Byb3BlcnR5T3B0aW9uYWxpdHkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBQ3JELE9BQU8sRUFBQyxpQkFBaUIsRUFBQyxNQUFNLGtDQUFrQyxDQUFDO0FBRW5FLE1BQU0sQ0FBQyxNQUFNLDBCQUEwQixHQUFHLENBQ3RDLElBQWlDLEVBQzFCLEVBQUU7SUFDVCxNQUFNLG9CQUFvQixHQUFHLGlCQUFpQixDQUFDLHNCQUFzQixDQUNqRSxJQUFJLEVBQ0osQ0FBQyxxQkFBcUIsQ0FBQyxDQUMxQixDQUFDO0lBRUYsTUFBTSx1QkFBdUIsR0FDekIsaUJBQWlCLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFcEQsT0FBTyxvQkFBb0IsSUFBSSxDQUFDLHVCQUF1QixDQUFDO0FBQzVELENBQUMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxNQUFNLDBCQUEwQixHQUFHLENBQ3RDLElBQWlDLEVBQzFCLEVBQUU7SUFDVCxNQUFNLG9CQUFvQixHQUFHLGlCQUFpQixDQUFDLHNCQUFzQixDQUNqRSxJQUFJLEVBQ0osQ0FBQyxhQUFhLENBQUMsQ0FDbEIsQ0FBQztJQUVGLE1BQU0sdUJBQXVCLEdBQ3pCLGlCQUFpQixDQUFDLHVCQUF1QixDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXBELE9BQU8sb0JBQW9CLElBQUksdUJBQXVCLENBQUM7QUFDM0QsQ0FBQyxDQUFDO0FBRUYsTUFBTSxJQUFJLEdBQUcsVUFBVSxDQUdyQjtJQUNFLElBQUksRUFBRSwyQ0FBMkM7SUFDakQsSUFBSSxFQUFFO1FBQ0YsSUFBSSxFQUFFO1lBQ0YsV0FBVyxFQUNQLHdEQUF3RDtTQUMvRDtRQUNELFFBQVEsRUFBRTtZQUNOLDBCQUEwQixFQUFFLHVFQUF1RTtZQUNuRywwQkFBMEIsRUFBRSwrREFBK0Q7U0FDOUY7UUFDRCxNQUFNLEVBQUUsRUFBRTtRQUNWLGNBQWMsRUFBRSxLQUFLO1FBQ3JCLElBQUksRUFBRSxZQUFZO0tBQ3JCO0lBQ0QsY0FBYyxFQUFFLEVBQUU7SUFFbEIsTUFBTSxDQUFDLE9BQU87UUFDVixPQUFPO1lBQ0gsa0JBQWtCLENBQUMsSUFBaUM7Z0JBQ2hELElBQUksMEJBQTBCLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztvQkFDbkMsT0FBTyxDQUFDLE1BQU0sQ0FBQzt3QkFDWCxJQUFJLEVBQUUsSUFBSTt3QkFDVixTQUFTLEVBQUUsNEJBQTRCO3FCQUMxQyxDQUFDLENBQUM7Z0JBQ1AsQ0FBQztnQkFDRCxJQUFJLDBCQUEwQixDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7b0JBQ25DLE9BQU8sQ0FBQyxNQUFNLENBQUM7d0JBQ1gsSUFBSSxFQUFFLElBQUk7d0JBQ1YsU0FBUyxFQUFFLDRCQUE0QjtxQkFDMUMsQ0FBQyxDQUFDO2dCQUNQLENBQUM7WUFDTCxDQUFDO1NBQ0osQ0FBQztJQUNOLENBQUM7Q0FDSixDQUFDLENBQUM7QUFFSCxlQUFlLElBQUksQ0FBQyJ9