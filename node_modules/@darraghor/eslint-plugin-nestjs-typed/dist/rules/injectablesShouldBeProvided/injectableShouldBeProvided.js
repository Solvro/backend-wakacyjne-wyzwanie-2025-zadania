import { createRule } from "../../utils/createRule.js";
// import FileEnumeratorWrapper from "../../utils/files/fileEnumerationWrapper";
import NestProvidedInjectableMapper from "../../utils/nestModules/nestProvidedInjectableMapper.js";
import { typedTokenHelpers } from "../../utils/typedTokenHelpers.js";
import FileEnumeratorWrapper from "../../utils/files/customFileEnumeratorWrapper.js";
let listOfPotentialNestModuleFiles;
let nestModuleMap;
const findModuleMappingsContaining = (className, propertyName, nestModuleMap) => {
    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-unused-vars
    const modules = [...nestModuleMap.entries()].filter(([_, entry]) => {
        return entry[propertyName].has(className);
    });
    return modules;
};
function convertNestModuleMapToString(nestModules) {
    // const uniqueValues = new Set<string>();
    const vals = [];
    nestModules.forEach((module) => {
        // Add all paths
        vals.push(module[0]);
    });
    // Convert the Set to an array and join with commas
    // return Array.from(uniqueValues).join(", ");
    return vals.join(", ");
}
const checkNode = (
// super fragile types but whatevs
node, decoratorName, propertyName, messageId, context) => {
    if (NestProvidedInjectableMapper.isNestInjectableThatIsNeverProvided(node)) {
        return;
    }
    if (typedTokenHelpers.nodeHasDecoratorsNamed(node, [decoratorName])) {
        const name = node.id?.name;
        if (!name) {
            return;
        }
        const foundModuleMaps = findModuleMappingsContaining(name, propertyName, nestModuleMap);
        if (foundModuleMaps.length === 1) {
            return;
        }
        // couldn't find map so error
        context.report({
            node: node,
            messageId: messageId,
            data: {
                numberOfReferences: foundModuleMaps.length,
                refLocations: convertNestModuleMapToString(foundModuleMaps),
                name: name,
            },
        });
    }
};
function initializeModuleMappings(sourcePath, filterFromPaths, context) {
    const mappedSourceDirectory = NestProvidedInjectableMapper.detectDirectoryToScanForFiles(sourcePath, process.cwd());
    listOfPotentialNestModuleFiles = FileEnumeratorWrapper.enumerateFiles({
        sourceGlobs: mappedSourceDirectory,
        extensions: [".ts"],
        filterFromPaths,
    });
    nestModuleMap = NestProvidedInjectableMapper.parseFileList(listOfPotentialNestModuleFiles, context);
}
const defaultOptions = [
    {
        src: ["src/**/*.ts"],
        filterFromPaths: ["dist", "node_modules", ".test.", ".spec."],
    },
];
const rule = createRule({
    name: "injectable-should-be-provided",
    meta: {
        docs: {
            description: "Public api methods should have documentation",
        },
        messages: {
            injectableInModule: `Expected Injectable "{{name}}" to be referenced in 1 module's providers array, but found {{numberOfReferences}} references ({{refLocations}}). If you added it already but this error still shows in your editor, please change one character in the injectable file to poke your eslint plugin.`,
            controllersInModule: `Expected Controller "{{name}}" to be referenced in 1 module's controllers array, but found {{numberOfReferences}} references ({{refLocations}}). If you added it already but this error still shows in your editor, please change one character in the controller file to poke your eslint plugin.`,
        },
        schema: [
            {
                type: "object",
                properties: {
                    src: {
                        description: "files/paths to be analyzed (only for provided injectable or controller)",
                        type: "array",
                        minItems: 1,
                        items: {
                            type: "string",
                            minLength: 1,
                        },
                    },
                    filterFromPaths: {
                        description: "strings to exclude from checks (only for provided injectable or controller)",
                        type: "array",
                        minItems: 1,
                        items: {
                            type: "string",
                            minLength: 1,
                        },
                    },
                },
            },
        ],
        type: "problem",
    },
    defaultOptions: defaultOptions,
    create(contextWithoutDefaults) {
        // @ts-ignore
        const context = contextWithoutDefaults.options &&
            contextWithoutDefaults.options.length > 0
            ? contextWithoutDefaults
            : // only apply the defaults when the user provides no config
                Object.setPrototypeOf({
                    options: defaultOptions,
                }, contextWithoutDefaults);
        const { src, filterFromPaths } = context.options[0] || {};
        if (nestModuleMap === undefined || nestModuleMap.size === 0) {
            initializeModuleMappings(src[0], filterFromPaths, context);
        }
        return {
            ClassDeclaration(node) {
                checkNode(node, "Injectable", "providers", "injectableInModule", context);
                checkNode(node, "Controller", "controllers", "controllersInModule", context);
            },
            "Program:exit"() {
                // map the source to a mapping thing
                // if not undefined set it to the mapping set
                const mappedProvidedInjectables = NestProvidedInjectableMapper.mapAllProvidedInjectablesInModuleOrProviderFile(context.sourceCode.ast, context.filename);
                if (mappedProvidedInjectables !== null) {
                    nestModuleMap.set(mappedProvidedInjectables[0], mappedProvidedInjectables[1]);
                }
            },
        };
    },
});
export default rule;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5qZWN0YWJsZVNob3VsZEJlUHJvdmlkZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcnVsZXMvaW5qZWN0YWJsZXNTaG91bGRCZVByb3ZpZGVkL2luamVjdGFibGVTaG91bGRCZVByb3ZpZGVkLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQztBQUNyRCxnRkFBZ0Y7QUFDaEYsT0FBTyw0QkFBNEIsTUFBTSx5REFBeUQsQ0FBQztBQUVuRyxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxrQ0FBa0MsQ0FBQztBQUluRSxPQUFPLHFCQUFxQixNQUFNLGtEQUFrRCxDQUFDO0FBRXJGLElBQUksOEJBQTBDLENBQUM7QUFDL0MsSUFBSSxhQUFzRCxDQUFDO0FBUzNELE1BQU0sNEJBQTRCLEdBQUcsQ0FDakMsU0FBaUIsRUFDakIsWUFBeUMsRUFDekMsYUFBc0QsRUFDaEIsRUFBRTtJQUN4QyxtR0FBbUc7SUFDbkcsTUFBTSxPQUFPLEdBQUcsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUU7UUFDL0QsT0FBTyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzlDLENBQUMsQ0FBQyxDQUFDO0lBRUgsT0FBTyxPQUFPLENBQUM7QUFDbkIsQ0FBQyxDQUFDO0FBQ0YsU0FBUyw0QkFBNEIsQ0FDakMsV0FBbUQ7SUFFbkQsMENBQTBDO0lBQzFDLE1BQU0sSUFBSSxHQUFhLEVBQUUsQ0FBQztJQUMxQixXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7UUFDM0IsZ0JBQWdCO1FBQ2hCLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFD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