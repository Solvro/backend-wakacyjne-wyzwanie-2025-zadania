import { createRule } from "../../utils/createRule.js";
import { TSESTree } from "@typescript-eslint/utils";
export const shouldTrigger = () => {
    return true;
};
export const standardDecoratorsToValidate = ["Controller", "Injectable"];
const rule = createRule({
    name: "no-duplicate-decorators",
    meta: {
        docs: {
            description: "Some decorators should only be used once on a property or class. This rule enforces that.",
        },
        messages: {
            noDuplicateDecorators: "You have listed the same decorator more than once. Was this intentional?",
        },
        schema: [
            {
                type: "object",
                properties: {
                    customList: {
                        description: "A list of custom decorators that this rule will validate for duplicates",
                        type: "array",
                        minItems: 0,
                        items: {
                            type: "string",
                            minLength: 1,
                        },
                    },
                },
            },
        ],
        hasSuggestions: true,
        type: "suggestion",
    },
    defaultOptions: [
        {
            customList: new Array(),
        },
    ],
    create(context) {
        const customListArrayItem = context.options[0];
        let decoratorsToValidate = customListArrayItem?.customList;
        if (!customListArrayItem?.customList ||
            customListArrayItem?.customList.length === 0) {
            decoratorsToValidate = standardDecoratorsToValidate;
        }
        return {
            ["PropertyDefinition,ClassDeclaration"](node) {
                const allDecorators = node.decorators;
                if (allDecorators && allDecorators.length > 1) {
                    const decoratorNames = allDecorators.map((decorator) => {
                        if (decorator.expression.type ===
                            TSESTree.AST_NODE_TYPES.CallExpression &&
                            decorator.expression.callee &&
                            decorator.expression.callee.type ===
                                TSESTree.AST_NODE_TYPES.Identifier) {
                            return decorator.expression.callee.name;
                        }
                        return "";
                    });
                    const duplicateDecorators = decoratorNames.filter((decoratorName, index) => {
                        return (decoratorName &&
                            decoratorNames.indexOf(decoratorName) !== index);
                    });
                    if (duplicateDecorators.length > 0 &&
                        decoratorsToValidate.some((decoratorToValidate) => duplicateDecorators.includes(decoratorToValidate))) {
                        context.report({
                            node: node,
                            messageId: "noDuplicateDecorators",
                            suggest: [
                                {
                                    messageId: "noDuplicateDecorators",
                                    fix: (fixer) => {
                                        const decoratorsToKeep = decoratorNames.filter((decoratorName, index) => {
                                            return (decoratorName &&
                                                decoratorNames.indexOf(decoratorName) === index);
                                        });
                                        const decoratorsToKeepText = decoratorsToKeep.join(", ");
                                        return fixer.replaceText(node, decoratorsToKeepText);
                                    },
                                },
                            ],
                        });
                    }
                }
            },
        };
    },
});
export default rule;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9EdXBsaWNhdGVEZWNvcmF0b3JzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3J1bGVzL25vRHVwbGljYXRlRGVjb3JhdG9ycy9ub0R1cGxpY2F0ZURlY29yYXRvcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBRXJELE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQU9sRCxNQUFNLENBQUMsTUFBTSxhQUFhLEdBQUcsR0FBWSxFQUFFO0lBQ3ZDLE9BQU8sSUFBSSxDQUFDO0FBQ2hCLENBQUMsQ0FBQztBQUNGLE1BQU0sQ0FBQyxNQUFNLDRCQUE0QixHQUFHLENBQUMsWUFBWSxFQUFFLFlBQVksQ0FBQyxDQUFDO0FBQ3pFLE1BQU0sSUFBSSxHQUFHLFVBQVUsQ0FBd0Q7SUFDM0UsSUFBSSxFQUFFLHlCQUF5QjtJQUMvQixJQUFJLEVBQUU7UUFDRixJQUFJLEVBQUU7WUFDRixXQUFXLEVBQ1AsMkZBQTJGO1NBQ2xHO1FBQ0QsUUFBUSxFQUFFO1lBQ04scUJBQXFCLEVBQ2pCLDBFQUEwRTtTQUNqRjtRQUNELE1BQU0sRUFBRTtZQUNKO2dCQUNJLElBQUksRUFBRSxRQUErQjtnQkFDckMsVUFBVSxFQUFFO29CQUNSLFVBQVUsRUFBRTt3QkFDUixXQUFXLEVBQ1AseUVBQXlFO3dCQUM3RSxJQUFJLEVBQUUsT0FBOEI7d0JBQ3BDLFFBQVEsRUFBRSxDQUFDO3dCQUNYLEtBQUssRUFBRTs0QkFDSCxJQUFJLEVBQUUsUUFBK0I7NEJBQ3JDLFNBQVMsRUFBRSxDQUFDO3lCQUNmO3FCQUNKO2lCQUNKO2FBQ0o7U0FDSjtRQUNELGNBQWMsRUFBRSxJQUFJO1FBQ3BCLElBQUksRUFBRSxZQUFZO0tBQ3JCO0lBQ0QsY0FBYyxFQUFFO1FBQ1o7WUFDSSxVQUFVLEVBQUUsSUFBSSxLQUFLLEVBQVU7U0FDbEM7S0FDSjtJQUVELE1BQU0s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