/* eslint-disable unicorn/prevent-abbreviations */
import { TSESTree } from "@typescript-eslint/utils";
import { createRule } from "../../utils/createRule.js";
const nestRequestMethodDecoratorNames = new Set([
    "Get",
    "Post",
    "Put",
    "Delete",
    "Patch",
    "Options",
    "Head",
    "All",
    "Sse",
]);
export const parsePathParts = (decorator) => {
    const decoratorArgument = decorator?.expression
        ?.arguments[0];
    if (decoratorArgument?.type === TSESTree.AST_NODE_TYPES.TemplateLiteral ||
        decoratorArgument?.type === TSESTree.AST_NODE_TYPES.Identifier) {
        return ["dareslint__skip"];
    }
    if (decoratorArgument?.type === TSESTree.AST_NODE_TYPES.Literal) {
        return [decoratorArgument.raw];
    }
    if (decoratorArgument?.type === TSESTree.AST_NODE_TYPES.ArrayExpression) {
        return decoratorArgument.elements.map((x) => x.raw);
    }
    if (decoratorArgument?.type === TSESTree.AST_NODE_TYPES.ObjectExpression) {
        return decoratorArgument.properties
            .filter((x) => x.key
            .name === "path")
            .map((x) => x.value.raw);
    }
    return [];
};
/**
 * nestjs allows for paths with _+?()*
 * this rule doesn't support parsing those so we'll just pass
 */
export const hasPathPartsAnyRegexParams = (pathPartsToCheck) => {
    // prettier-ignore
    const specialCharacterRegex = /(dareslint__skip|\*|\+|\?|\(|\)|_)/; //new RegExp("([\?\+\*\_\(\)])")
    return pathPartsToCheck.some((pathPart) => {
        return specialCharacterRegex.test(pathPart);
    });
};
/**
 * Checks if there is a matching path part for the paramName
 * @param paramName
 * @param pathPartsToCheck
 * @returns
 */
export const isParameterNameIncludedInAPathPart = (paramName, pathPartsToCheck) => {
    return pathPartsToCheck.some((pathPart) => {
        return (
        // note to reader: this might be better as a regex. feel free to open a pr!
        pathPart === `":${paramName}"` ||
            pathPart === `':${paramName}'` ||
            pathPart.includes(`/:${paramName}/`) ||
            pathPart.includes(`/:${paramName}"`) ||
            pathPart.includes(`":${paramName}/`) ||
            pathPart.includes(`/:${paramName}'`) ||
            pathPart.includes(`':${paramName}/`));
    });
};
export const shouldTrigger = (decorator, ruleOptions) => {
    if (!decorator) {
        return {
            hasColonInName: false,
            paramNameNotMatchedInPath: false,
        };
    }
    // grab the param name
    const paramName = (decorator?.expression)
        .arguments[0]?.value;
    // if there's no param name get out of here
    if (!paramName || paramName === "") {
        return {
            hasColonInName: false,
            paramNameNotMatchedInPath: false,
        };
    }
    // param names don't need the colon
    if (paramName.startsWith(":")) {
        return {
            hasColonInName: true,
            paramNameNotMatchedInPath: false,
        };
    }
    let pathPartsToCheck = [];
    // grab any controller path parts
    if (ruleOptions[0].shouldCheckController) {
        // eslint-disable-next-line @typescript-eslint/non-nullable-type-assertion-style
        const controllerDecorator = (decorator.parent.parent?.parent?.parent
            ?.parent).decorators.find((d) => {
            return (d.expression
                .callee.name === "Controller");
        });
        pathPartsToCheck = pathPartsToCheck.concat(parsePathParts(controllerDecorator));
    }
    // grab any api method path parts from method decorator
    const methodDefinition = decorator.parent.parent
        ?.parent;
    // eslint-disable-next-line @typescript-eslint/non-nullable-type-assertion-style
    const methodDecorator = methodDefinition.decorators.find((d) => {
        return nestRequestMethodDecoratorNames.has(d.expression
            .callee.name);
    });
    pathPartsToCheck = pathPartsToCheck.concat(parsePathParts(methodDecorator));
    const shouldIgnoreThisSetOfRoutes = 
    // is a template literal argument
    // is an identifier argument
    hasPathPartsAnyRegexParams(pathPartsToCheck);
    if (shouldIgnoreThisSetOfRoutes) {
        return {
            hasColonInName: false,
            paramNameNotMatchedInPath: false,
        };
    }
    // check that the param name is in one path part
    return {
        hasColonInName: false,
        paramNameNotMatchedInPath: !isParameterNameIncludedInAPathPart(paramName, pathPartsToCheck),
        paramName,
    };
};
const defaultRuleOptions = [{ shouldCheckController: true }];
const rule = createRule({
    name: "param-decorator-name-matches-route-param",
    meta: {
        docs: {
            description: 'Param decorators with a name parameter e.g. Param("myvar") should match a specified route parameter - e.g. Get(":myvar")',
        },
        messages: {
            paramIdentifierDoesntNeedColon: "You don't need to specify the colon (:) in a Param decorator",
            paramIdentifierShouldMatchRouteOrController: 'The Param "{{paramName}}" could not be found in the related route or controller',
            paramIdentifierShouldMatchRouteOnly: 'The Param "{{paramName}}" could not be found in the related route',
        },
        schema: [
            {
                type: "object",
                properties: {
                    shouldCheckController: {
                        description: "If the name in the @Controller() decorator should be checked for route param matches or not. Turn this option off if you use variable for Controller paths that do not contain route params.",
                        type: "boolean",
                    },
                },
            },
        ],
        hasSuggestions: false,
        type: "suggestion",
    },
    defaultOptions: defaultRuleOptions,
    create(contextWithoutDefaults) {
        const context = contextWithoutDefaults.options &&
            contextWithoutDefaults.options.length > 0
            ? contextWithoutDefaults
            : // only apply the defaults when the user provides no config
                Object.setPrototypeOf({
                    options: defaultRuleOptions,
                }, contextWithoutDefaults);
        return {
            Decorator(node) {
                if (node.expression
                    .callee.name !== "Param") {
                    return;
                }
                const result = shouldTrigger(node, context.options);
                if (result.paramNameNotMatchedInPath) {
                    context.report({
                        node: node,
                        messageId: context.options[0].shouldCheckController
                            ? "paramIdentifierShouldMatchRouteOrController"
                            : "paramIdentifierShouldMatchRouteOnly",
                        data: { paramName: result.paramName },
                    });
                }
                if (result.hasColonInName) {
                    context.report({
                        node: node,
                        messageId: "paramIdentifierDoesntNeedColon",
                    });
                }
            },
        };
    },
});
export default rule;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyYW1EZWNvcmF0b3JOYW1lTWF0Y2hlc1JvdXRlUGFyYW0uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcnVsZXMvcGFyYW1EZWNvcmF0b3JOYW1lTWF0Y2hlc1JvdXRlUGFyYW0vcGFyYW1EZWNvcmF0b3JOYW1lTWF0Y2hlc1JvdXRlUGFyYW0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsa0RBQWtEO0FBQ2xELE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUNsRCxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFxQnJELE1BQU0sK0JBQStCLEdBQUcsSUFBSSxHQUFHLENBQUM7SUFDNUMsS0FBSztJQUNMLE1BQU07SUFDTixLQUFLO0lBQ0wsUUFBUTtJQUNSLE9BQU87SUFDUCxTQUFTO0lBQ1QsTUFBTTtJQUNOLEtBQUs7SUFDTCxLQUFLO0NBQ1IsQ0FBQyxDQUFDO0FBRUgsTUFBTSxDQUFDLE1BQU0sY0FBYyxHQUFHLENBQUMsU0FBNkIsRUFBWSxFQUFFO0lBQ3RFLE1BQU0saUJBQWlCLEdBQUksU0FBUyxFQUFFLFVBQXNDO1FBQ3hFLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRW5CLElBQ0ksaUJBQWlCLEVBQUUsSUFBSSxLQUFLLFFBQVEsQ0FBQyxjQUFjLENBQUMsZUFBZTtRQUNuRSxpQkFBaUIsRUFBRSxJQUFJLEtBQUssUUFBUSxDQUFDLGNBQWMsQ0FBQyxVQUFVLEVBQ2hFLENBQUM7UUFDQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUMvQixDQUFDO0lBRUQsSUFBSSxpQkFBaUIsRUFBRSxJQUFJLEtBQUssUUFBUSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUM5RCxPQUFPLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUNELElBQUksaUJBQWlCLEVBQUUsSUFBSSxLQUFLLFFBQVEs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