import { createRule } from "../../utils/createRule.js";
//import util from "util";
import { nestProviderAstParser } from "../../utils/nestModules/nestProviderAstParser.js";
const isNestProvider = (node) => {
    // should be a nest provider - note this doesn't check the Provider used is an import actually from nest. Assumes nest Provider. Will change if this is annoying:)
    // edit 03/06/2023 - it was annoying and someone complained on github so I added a check for a "useFactory" property on the Provider declaration
    const isNestProvider = node.id.typeAnnotation?.typeAnnotation
        ?.typeName?.name === "Provider" &&
        // and there is a useFactory property in the declaration
        nestProviderAstParser.findProvideProperty(node, "useFactory");
    if (!isNestProvider) {
        return false;
    }
    return true;
};
const isNestProviderWithFactory = (node) => {
    // should be a nest provider - note this doesn't check the Provider used is an import actually from nest. Assumes nest Provider. Will change if this is annoying:)
    // edit 03/06/2023 - it was annoying and someone complained on github so I added a check for a "useFactory" property on the Provider declaration
    const isNestProvider = 
    // and there is a useFactory property in the declaration
    nestProviderAstParser.findProvideProperty(node, "useFactory");
    if (!isNestProvider) {
        return false;
    }
    return true;
};
export const hasMismatchedInjected = (node) => {
    // count number of factory params
    const factoryParameterCount = (nestProviderAstParser.findProvideProperty(node, "useFactory")
        ?.value).params.length;
    // Count number of injected params
    const injectedParameter = nestProviderAstParser.findProvideProperty(node, "inject")?.value;
    const injectedParameterCount = injectedParameter
        ? injectedParameter.elements.length
        : 0;
    // is there a mismatch?
    return injectedParameterCount !== factoryParameterCount;
};
const rule = createRule({
    name: "provided-injected-should-match-factory-parameters",
    meta: {
        docs: {
            description: "The injected items in a provider should typically match the parameters to the factory method used",
        },
        messages: {
            mainMessage: `The injected items don't match the factory method parameters, did you forget to add one?`,
        },
        schema: [],
        type: "problem",
    },
    defaultOptions: [],
    create(context) {
        return {
            "Decorator Property:has(Identifier[name=providers]) > ArrayExpression > ObjectExpression"(node) {
                if (isNestProviderWithFactory(node) &&
                    hasMismatchedInjected(node)) {
                    context.report({
                        node: node,
                        messageId: "mainMessage",
                    });
                }
            },
            VariableDeclarator(node) {
                if (isNestProvider(node) && hasMismatchedInjected(node)) {
                    context.report({
                        node: node,
                        messageId: "mainMessage",
                    });
                }
            },
        };
    },
});
export default rule;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUHJvdmlkZXJJbmplY3RlZFNob3VsZE1hdGNoRmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ydWxlcy9wcm92aWRlckluamVjdGVkU2hvdWxkTWF0Y2hGYWN0b3J5L1Byb3ZpZGVySW5qZWN0ZWRTaG91bGRNYXRjaEZhY3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBRXJELDBCQUEwQjtBQUMxQixPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSxrREFBa0QsQ0FBQztBQUV2RixNQUFNLGNBQWMsR0FBRyxDQUFDLElBQWlDLEVBQVcsRUFBRTtJQUNsRSxrS0FBa0s7SUFDbEssZ0pBQWdKO0lBQ2hKLE1BQU0sY0FBYyxHQUVYLElBQUksQ0FBQyxFQUFFLENBQUMsY0FBYyxFQUFFLGNBQTJDO1FBQ2hFLEVBQUUsUUFDVCxFQUFFLElBQUksS0FBSyxVQUFVO1FBQ3RCLHdEQUF3RDtRQUN4RCxxQkFBcUIsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFFbEUsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ2xCLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNoQixDQUFDLENBQUM7QUFDRixNQUFNLHlCQUF5QixHQUFHLENBQzlCLElBQStCLEVBQ3hCLEVBQUU7SUFDVCxrS0FBa0s7SUFDbEssZ0pBQWdKO0lBQ2hKLE1BQU0sY0FBYztJQUNoQix3REFBd0Q7SUFDeEQscUJBQXFCLENBQUMsbUJBQW1CLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBRWxFLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUNsQixPQUFPLEtBQUssQ0FBQztJQUNqQixDQUFDO0lBQ0QsT0FBTyxJQUFJLENBQUM7QUFDaEIsQ0FBQyxDQUFDO0FBRUYsTUFBTSxDQUFDLE1BQU0scUJBQXFCLEdBQUcsQ0FDakMsSUFBNkQsRUFDdEQsRUFBRTtJQUNULGlDQUFpQztJQUNqQyxNQUFNLHFCQUFxQixHQUFHLENBQzFCLHFCQUFxQixDQUFDLG1CQUFtQixDQUFDLElBQUksRUFBRSxZQUFZLENBQUM7UUFDekQsRUFBRSxLQUNULENBQUEsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDO0lBRWhCLGtDQUFrQztJQUNsQyxNQUFNLGlCQUFpQixHQUFHLHFCQUFxQixDQUFDLG1CQUFtQixDQUMvRCxJQUFJLEVBQ0osUUFBUSxDQUNYLEVBQUUsS0FBNEMsQ0FBQztJQUVoRCxNQUFNLHNCQUFzQixHQUFHLGlCQUFpQjtRQUM1QyxDQUFDLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLE1BQU07UUFDbkMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUVSLHVCQUF1QjtJQUN2QixPQUFPLHNCQUFzQixLQUFLLHFCQUFxQixDQUFDO0FBQzVELENBQUMsQ0FBQztBQUVGLE1BQU0sSUFBSSxHQUFHLFVBQVUsQ0FBb0I7SUFDdkMsSUFBSSxFQUFFLG1EQUFtRDtJQUN6RCxJQUFJLEVBQUU7UUFDRixJQUFJLEVBQUU7WUFDRixXQUFXLEVBQ1AsbUdBQW1HO1NBQzFHO1FBQ0QsUUFBUSxFQUFFO1lBQ04sV0FBVyxFQUFFLDBGQUEwRjtTQUMxRztRQUNELE1BQU0sRUFBRSxFQUFFO1FBQ1YsSUFBSSxFQUFFLFNBQVM7S0FDbEI7SUFDRCxjQUFjLEVBQUUsRUFBRTtJQUVsQixNQUFNLENBQUMsT0FBTztRQUNWLE9BQU87WUFDSCx5RkFBeUYsQ0FDckYsSUFBK0I7Z0JBRS9CLElBQ0kseUJBQXlCLENBQUMsSUFBSSxDQUFDO29CQUMvQixxQkFBcUIsQ0FBQyxJQUFJLENBQUMsRUFDN0IsQ0FBQztvQkFDQyxPQUFPLENBQUMsTUFBTSxDQUFDO3dCQUNYLElBQUksRUFBRSxJQUFJO3dCQUNWLFNBQVMsRUFBRSxhQUFhO3FCQUMzQixDQUFDLENBQUM7Z0JBQ1AsQ0FBQztZQUNMLENBQUM7WUFDRCxrQkFBa0IsQ0FBQyxJQUFpQztnQkFDaEQsSUFBSSxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUkscUJBQXFCLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztvQkFDdEQsT0FBTyxDQUFDLE1BQU0sQ0FBQzt3QkFDWCxJQUFJLEVBQUUsSUFBSTt3QkFDVixTQUFTLEVBQUUsYUFBYTtxQkFDM0IsQ0FBQyxDQUFDO2dCQUNQLENBQUM7WUFDTCxDQUFDO1NBQ0osQ0FBQztJQUNOLENBQUM7Q0FDSixDQUFDLENBQUM7QUFFSCxlQUFlLElBQUksQ0FBQyJ9