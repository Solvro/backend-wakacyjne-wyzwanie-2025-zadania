import { AST_NODE_TYPES } from "@typescript-eslint/utils";
import { createRule } from "../../utils/createRule.js";
import { typedTokenHelpers } from "../../utils/typedTokenHelpers.js";
import ArraySetResultModel from "./arraySetResultModel.js";
export const shouldSetArrayProperty = (node) => {
    const decorators = typedTokenHelpers.getDecoratorsNamed(node, [
        "ValidateNested",
    ]);
    if (decorators.length === 0) {
        return new ArraySetResultModel(false, false);
    }
    const firstArgumentToDecorator = decorators[0].expression.arguments[0];
    const hasEachSetInOptions = typedTokenHelpers.getPropertyValueEqualsExpected(firstArgumentToDecorator, "each", true);
    // handle string[] or Array<string>
    const isArrayType = (node.typeAnnotation?.typeAnnotation)
        .typeName?.name === "Array";
    const isTypescriptArrayType = node.typeAnnotation?.typeAnnotation.type === AST_NODE_TYPES.TSArrayType;
    const isAnArrayLikeType = isArrayType || isTypescriptArrayType;
    return new ArraySetResultModel(isAnArrayLikeType && !hasEachSetInOptions, !isAnArrayLikeType && hasEachSetInOptions);
};
const rule = createRule({
    name: "validate-nested-of-array-should-set-each",
    meta: {
        docs: {
            description: "If you set ValidateNested() on an array, you should set {each: true} in the options",
        },
        messages: {
            shouldSetEachPropertyTrue: `ValidateNested should have {each: true} when used on an array`,
            shouldSetEachPropertyFalse: `ValidateNested should not have {each: true} when used on non-arrays. Note: If this is a custom array class please ignore this suggestion, you should validate each in that case.`,
        },
        schema: [],
        hasSuggestions: false,
        type: "suggestion",
    },
    defaultOptions: [],
    create(context) {
        return {
            PropertyDefinition: (node) => {
                const shouldSetArrayResults = shouldSetArrayProperty(node);
                if (shouldSetArrayResults.isArrayShouldBeSetFalse) {
                    context.report({
                        node: node,
                        messageId: "shouldSetEachPropertyFalse",
                    });
                }
                if (shouldSetArrayResults.isArrayShouldBeSetTrue) {
                    context.report({
                        node: node,
                        messageId: "shouldSetEachPropertyTrue",
                    });
                }
            },
        };
    },
});
export default rule;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGVOZXN0ZWRPZkFycmF5U2hvdWxkU2V0RWFjaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ydWxlcy92YWxpZGF0ZU5lc3RlZE9mQXJyYXlTaG91bGRTZXRFYWNoL3ZhbGlkYXRlTmVzdGVkT2ZBcnJheVNob3VsZFNldEVhY2gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLGNBQWMsRUFBVyxNQUFNLDBCQUEwQixDQUFDO0FBQ2xFLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQztBQUNyRCxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxrQ0FBa0MsQ0FBQztBQUNuRSxPQUFPLG1CQUFtQixNQUFNLDBCQUEwQixDQUFDO0FBRTNELE1BQU0sQ0FBQyxNQUFNLHNCQUFzQixHQUFHLENBQ2xDLElBQWlDLEVBQ2QsRUFBRTtJQUNyQixNQUFNLFVBQVUsR0FBRyxpQkFBaUIsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUU7UUFDMUQsZ0JBQWdCO0tBQ25CLENBQUMsQ0FBQztJQUVILElBQUksVUFBVSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUMxQixPQUFPLElBQUksbUJBQW1CLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFRCxNQUFNLHdCQUF3QixHQUMxQixVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFDakIsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUE4QixDQUFDO0lBRTVDLE1BQU0sbUJBQW1CLEdBQ3JCLGlCQUFpQixDQUFDLDhCQUE4QixDQUM1Qyx3QkFBd0IsRUFDeEIsTUFBTSxFQUNOLElBQUksQ0FDUCxDQUFDO0lBQ04sbUNBQW1DO0lBQ25DLE1BQU0sV0FBVyxHQUVULENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRSxjQUEyQyxDQUFBO1NBQzVELFFBQ1IsRUFBRSxJQUFJLEtBQUssT0FBTyxDQUFDO0lBQ3hCLE1BQU0scUJBQXFCLEdBQ3ZCLElBQUksQ0FBQyxjQUFjLEVBQUUsY0FBYyxDQUFDLElBQUksS0FBSyxjQUFjLENBQUMsV0FBVyxDQUFDO0lBQzVFLE1BQU0saUJBQWlCLEdBQUcsV0FBVyxJQUFJLHFCQUFxQixDQUFDO0lBRS9ELE9BQU8sSUFBSSxtQkFBbUIsQ0FDMUIsaUJBQWlCLElBQUksQ0FBQyxtQkFBbUIsRUFDekMsQ0FBQyxpQkFBaUIsSUFBSSxtQkFBbUIsQ0FDNUMsQ0FBQztBQUNOLENBQUMsQ0FBQztBQUVGLE1BQU0sSUFBSSxHQUFHLFVBQVUsQ0FHckI7SUFDRSxJQUFJLEVBQUUsMENBQTBDO0lBQ2hELElBQUksRUFBRTtRQUNGLElBQUksRUFBRTtZQUNGLFdBQVcsRUFDUCxxRkFBcUY7U0FDNUY7UUFDRCxRQUFRLEVBQUU7WUFDTix5QkFBeUIsRUFBRSwrREFBK0Q7WUFDMUYsMEJBQTBCLEVBQUUsa0xBQWtMO1NBQ2pOO1FBQ0QsTUFBTSxFQUFFLEVBQUU7UUFDVixjQUFjLEVBQUUsS0FBSztRQUNyQixJQUFJLEVBQUUsWUFBWTtLQUNyQjtJQUNELGNBQWMsRUFBRSxFQUFFO0lBRWxCLE1BQU0sQ0FBQyxPQUFPO1FBQ1YsT0FBTztZQUNILGtCQUFrQixFQUFFLENBQUMsSUFBbUIsRUFBRSxFQUFFO2dCQUN4QyxNQUFNLHFCQUFxQixHQUFHLHNCQUFzQixDQUNoRCxJQUFtQyxDQUN0QyxDQUFDO2dCQUVGLElBQUkscUJBQXFCLENBQUMsdUJBQXVCLEVBQUUsQ0FBQztvQkFDaEQsT0FBTyxDQUFDLE1BQU0sQ0FBQzt3QkFDWCxJQUFJLEVBQUUsSUFBSTt3QkFDVixTQUFTLEVBQUUsNEJBQTRCO3FCQUMxQyxDQUFDLENBQUM7Z0JBQ1AsQ0FBQztnQkFDRCxJQUFJLHFCQUFxQixDQUFDLHNCQUFzQixFQUFFLENBQUM7b0JBQy9DLE9BQU8sQ0FBQyxNQUFNLENBQUM7d0JBQ1gsSUFBSSxFQUFFLElBQUk7d0JBQ1YsU0FBUyxFQUFFLDJCQUEyQjtxQkFDekMsQ0FBQyxDQUFDO2dCQUNQLENBQUM7WUFDTCxDQUFDO1NBQ0osQ0FBQztJQUNOLENBQUM7Q0FDSixDQUFDLENBQUM7QUFFSCxlQUFlLElBQUksQ0FBQyJ9