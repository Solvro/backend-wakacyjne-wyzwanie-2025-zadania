import { AST_NODE_TYPES, TSESTree } from "@typescript-eslint/utils";
import { parse } from "@typescript-eslint/parser";
import ts from "typescript";
import * as tsutilsImp from "ts-api-utils";
const tsutils = tsutilsImp;
export const typedTokenHelpers = {
    decoratorsThatCouldMeanTheDevIsValidatingAnArray: [
        "IsArray",
        "ArrayMinSize",
        "ArrayMinSize",
        "ArrayContains",
        "ArrayNotContains",
        "ArrayNotEmpty",
        "ArrayUnique",
    ],
    isTypeArrayTypeOrUnionOfArrayTypes(node, parserService, checker) {
        if (node.typeAnnotation?.typeAnnotation
            .type === TSESTree.AST_NODE_TYPES.TSArrayType) {
            return true;
        }
        const nodeType = this.getNodeType(node, parserService, checker);
        if (checker.isArrayType(nodeType)) {
            return true;
        }
        for (const t of tsutils.unionTypeParts(nodeType)) {
            if (!checker.isArrayType(t)) {
                return false;
            }
        }
        return true;
    },
    getNodeType(node, parserService, checker) {
        const tsNode = parserService.esTreeNodeToTSNodeMap.get(node);
        return typedTokenHelpers.getConstrainedTypeAtLocation(checker, tsNode);
    },
    expressionNodeIsArrayType(node, parserService, checker) {
        const nodeType = this.getNodeType(node, parserService, checker);
        return checker.isArrayType(nodeType);
    },
    getPropertyValueEqualsExpected(firstArgument, propertyName, expectedValue) {
        let didMatchExpectedValues = false;
        if (firstArgument !== undefined) {
            const foundPropertyOfName = firstArgument.properties.find((p) => p.type === TSESTree.AST_NODE_TYPES.Property &&
                p.key.name === propertyName);
            didMatchExpectedValues =
                foundPropertyOfName !== undefined &&
                    foundPropertyOfName.type === TSESTree.AST_NODE_TYPES.Property &&
                    foundPropertyOfName.value.value ===
                        expectedValue;
        }
        return didMatchExpectedValues;
    },
    getConstrainedTypeAtLocation(checker, node) {
        const nodeType = checker.getTypeAtLocation(node);
        const constrained = checker.getBaseConstraintOfType(nodeType);
        return constrained ?? nodeType;
    },
    nodeHasDecoratorsNamed(n, decoratorNames) {
        const decorators = this.getDecoratorsNamed(n, decoratorNames);
        return decorators.length > 0;
    },
    getDecoratorsNamed(n, decoratorNames) {
        const decorators = n.decorators.filter((d) => {
            const factoryMethodDecoratorIdentifier = d.expression
                .callee?.name;
            const decoratorIdentifier = d.expression
                .name;
            return decoratorNames.includes(factoryMethodDecoratorIdentifier ?? decoratorIdentifier ?? "");
        });
        return decorators || [];
    },
    parseStringToAst(code, path, context) {
        return parse(code, {
            filePath: path,
            range: true,
            tokens: true,
            loc: true,
            ...context.parserOptions,
        });
    },
    isEnumType(type) {
        // if for some reason this returns true...
        if (tsutils.isTypeFlagSet(type, ts.TypeFlags.Enum))
            return true;
        if (tsutils.isTypeFlagSet(type, ts.TypeFlags.EnumLike))
            return true;
        // it's not an enum type if it's an enum literal type
        if (tsutils.isTypeFlagSet(type, ts.TypeFlags.EnumLiteral) &&
            !type.isUnion())
            return false;
        // get the symbol and check if its value declaration is an enum declaration
        const symbol = type.getSymbol();
        if (symbol == null)
            return false;
        const { valueDeclaration } = symbol;
        return (valueDeclaration != null &&
            valueDeclaration.kind === ts.SyntaxKind.EnumDeclaration);
    },
    isOptionalPropertyValue(node) {
        const isUndefinedType = node.typeAnnotation?.typeAnnotation?.types?.find((t) => t.type === AST_NODE_TYPES.TSUndefinedKeyword) !== undefined;
        const isOptionalPropertyValue = node.optional || isUndefinedType || false;
        return isOptionalPropertyValue;
    },
    /**
     * Checks if an import is an import of the given decorator name
     * @param imp
     * @param decoratorName
     */
    importIsDecorator(imp, decoratorName) {
        const isFromClassValidator = imp.source.value.startsWith("class-validator");
        const isDecoratorImport = imp.specifiers.some((specifier) => specifier.local.name === decoratorName);
        return isFromClassValidator && isDecoratorImport;
    },
    /**
     * Checks if decorator is in imports of a node
     * @param imports
     * @param decorator
     */
    decoratorIsImportedFromClassValidator(imports, decorator) {
        const decoratorName = this.getDecoratorName(decorator);
        if (!decoratorName) {
            return false;
        }
        return imports.some((imp) => typedTokenHelpers.importIsDecorator(imp, decoratorName));
    },
    /**
     * Checks whether a decorator is a class validator decorator
     * @param program The root program node
     * @param decorator The decorator node
     */
    decoratorIsClassValidatorDecorator(program, decorator) {
        if (!program) {
            return false;
        }
        const imports = program.body.filter((node) => node.type === TSESTree.AST_NODE_TYPES.ImportDeclaration);
        return typedTokenHelpers.decoratorIsImportedFromClassValidator(imports, decorator);
    },
    /**
     * Gets the root program of a node
     * @param node
     */
    getRootProgram(node) {
        let root = node;
        while (root.parent) {
            if (root.parent.type === TSESTree.AST_NODE_TYPES.Program) {
                return root.parent;
            }
            root = root.parent;
        }
        return null;
    },
    /**
     * Gets all the decorators actually imported from class-validator lib or decorators that were included in the additionalCustomValidatorDecorators options
     * @param node PropertyDefinition node
     */
    getValidationDecorators(node, additionalCustomValidatorDecorators = []) {
        const program = typedTokenHelpers.getRootProgram(node);
        const { decorators } = node;
        return (decorators.filter((decorator) => {
            const isClassValidatorDecorator = typedTokenHelpers.decoratorIsClassValidatorDecorator(program, decorator);
            const decoratorName = typedTokenHelpers.getDecoratorName(decorator);
            const isCustomClassValidatorDecorator = decoratorName === null
                ? false
                : additionalCustomValidatorDecorators.includes(decoratorName);
            return (isCustomClassValidatorDecorator || isClassValidatorDecorator);
        }) ?? []);
    },
    /**
     * Checks if the decorator is the IsEnum decorator
     * @param decorator
     */
    decoratorIsIsEnum(decorator) {
        const decoratorName = this.getDecoratorName(decorator);
        return decoratorName === "IsEnum";
    },
    /** Checks if the decorator is the IsObject decorator
     * @param decorator
     */
    decoratorIsIsObject(decorator) {
        const decoratorName = this.getDecoratorName(decorator);
        return decoratorName === "IsObject";
    },
    /**
     * Gets the name of a decorator
     * Returns null if no name is found
     * @param decorator
     */
    getDecoratorName(decorator) {
        if (decorator.expression.type !== TSESTree.AST_NODE_TYPES.CallExpression) {
            return null;
        }
        if (decorator.expression.callee.type !==
            TSESTree.AST_NODE_TYPES.Identifier) {
            return null;
        }
        return decorator.expression.callee.name;
    },
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZWRUb2tlbkhlbHBlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMvdHlwZWRUb2tlbkhlbHBlcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLGNBQWMsRUFBWSxRQUFRLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUM1RSxPQUFPLEVBQUMsS0FBSyxFQUFpQixNQUFNLDJCQUEyQixDQUFDO0FBQ2hFLE9BQU8sRUFBRSxNQUFNLFlBQVksQ0FBQztBQUM1QixPQUFPLEtBQUssVUFBVSxNQUFNLGNBQWMsQ0FBQztBQUUzQyxNQUFNLE9BQU8sR0FBRyxVQUFVLENBQUM7QUFFM0IsTUFBTSxDQUFDLE1BQU0saUJBQWlCLEdBQUc7SUFDN0IsZ0RBQWdELEVBQUU7UUFDOUMsU0FBUztRQUNULGNBQWM7UUFDZCxjQUFjO1FBQ2QsZUFBZTtRQUNmLGtCQUFrQjtRQUNsQixlQUFlO1FBQ2YsYUFBYTtLQUNoQjtJQUNELGtDQUFrQyxDQUM5QixJQUFtQixFQUNuQixhQUE2QixFQUM3QixPQUF1QjtRQUV2QixJQUNLLElBQW9DLENBQUMsY0FBYyxFQUFFLGNBQWM7YUFDL0QsSUFBSSxLQUFLLFFBQVEsQ0FBQyxjQUFjLENBQUMsV0FBVyxFQUNuRCxDQUFDO1lBQ0MsT0FBTyxJQUFJLENBQUM7UUFDaEIsQ0FBQztRQUVELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNoRSxJQUFJLE9BQU8sQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQztZQUNoQyxPQUFPLElBQUksQ0FBQztRQUNoQixDQUFDO1FBQ0QsS0FBSyxNQUFNLENBQUMsSUFBSSxPQUFPLENBQUMsY0FBYyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7WUFDL0MsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUs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