import {
  typescriptStrict,
  unicorn
} from "./chunk-VD4FWSAD.js";
import {
  imports
} from "./chunk-VSUL3MI5.js";
import "./chunk-HM3MY7J3.js";
import {
  __commonJS,
  __toESM,
  init_esm_shims
} from "./chunk-J5OUMHDO.js";

// node_modules/eslint-utils/node_modules/eslint-visitor-keys/lib/visitor-keys.json
var require_visitor_keys = __commonJS({
  "node_modules/eslint-utils/node_modules/eslint-visitor-keys/lib/visitor-keys.json"(exports, module) {
    module.exports = {
      AssignmentExpression: [
        "left",
        "right"
      ],
      AssignmentPattern: [
        "left",
        "right"
      ],
      ArrayExpression: [
        "elements"
      ],
      ArrayPattern: [
        "elements"
      ],
      ArrowFunctionExpression: [
        "params",
        "body"
      ],
      AwaitExpression: [
        "argument"
      ],
      BlockStatement: [
        "body"
      ],
      BinaryExpression: [
        "left",
        "right"
      ],
      BreakStatement: [
        "label"
      ],
      CallExpression: [
        "callee",
        "arguments"
      ],
      CatchClause: [
        "param",
        "body"
      ],
      ChainExpression: [
        "expression"
      ],
      ClassBody: [
        "body"
      ],
      ClassDeclaration: [
        "id",
        "superClass",
        "body"
      ],
      ClassExpression: [
        "id",
        "superClass",
        "body"
      ],
      ConditionalExpression: [
        "test",
        "consequent",
        "alternate"
      ],
      ContinueStatement: [
        "label"
      ],
      DebuggerStatement: [],
      DoWhileStatement: [
        "body",
        "test"
      ],
      EmptyStatement: [],
      ExportAllDeclaration: [
        "exported",
        "source"
      ],
      ExportDefaultDeclaration: [
        "declaration"
      ],
      ExportNamedDeclaration: [
        "declaration",
        "specifiers",
        "source"
      ],
      ExportSpecifier: [
        "exported",
        "local"
      ],
      ExpressionStatement: [
        "expression"
      ],
      ExperimentalRestProperty: [
        "argument"
      ],
      ExperimentalSpreadProperty: [
        "argument"
      ],
      ForStatement: [
        "init",
        "test",
        "update",
        "body"
      ],
      ForInStatement: [
        "left",
        "right",
        "body"
      ],
      ForOfStatement: [
        "left",
        "right",
        "body"
      ],
      FunctionDeclaration: [
        "id",
        "params",
        "body"
      ],
      FunctionExpression: [
        "id",
        "params",
        "body"
      ],
      Identifier: [],
      IfStatement: [
        "test",
        "consequent",
        "alternate"
      ],
      ImportDeclaration: [
        "specifiers",
        "source"
      ],
      ImportDefaultSpecifier: [
        "local"
      ],
      ImportExpression: [
        "source"
      ],
      ImportNamespaceSpecifier: [
        "local"
      ],
      ImportSpecifier: [
        "imported",
        "local"
      ],
      JSXAttribute: [
        "name",
        "value"
      ],
      JSXClosingElement: [
        "name"
      ],
      JSXElement: [
        "openingElement",
        "children",
        "closingElement"
      ],
      JSXEmptyExpression: [],
      JSXExpressionContainer: [
        "expression"
      ],
      JSXIdentifier: [],
      JSXMemberExpression: [
        "object",
        "property"
      ],
      JSXNamespacedName: [
        "namespace",
        "name"
      ],
      JSXOpeningElement: [
        "name",
        "attributes"
      ],
      JSXSpreadAttribute: [
        "argument"
      ],
      JSXText: [],
      JSXFragment: [
        "openingFragment",
        "children",
        "closingFragment"
      ],
      Literal: [],
      LabeledStatement: [
        "label",
        "body"
      ],
      LogicalExpression: [
        "left",
        "right"
      ],
      MemberExpression: [
        "object",
        "property"
      ],
      MetaProperty: [
        "meta",
        "property"
      ],
      MethodDefinition: [
        "key",
        "value"
      ],
      NewExpression: [
        "callee",
        "arguments"
      ],
      ObjectExpression: [
        "properties"
      ],
      ObjectPattern: [
        "properties"
      ],
      PrivateIdentifier: [],
      Program: [
        "body"
      ],
      Property: [
        "key",
        "value"
      ],
      PropertyDefinition: [
        "key",
        "value"
      ],
      RestElement: [
        "argument"
      ],
      ReturnStatement: [
        "argument"
      ],
      SequenceExpression: [
        "expressions"
      ],
      SpreadElement: [
        "argument"
      ],
      Super: [],
      SwitchStatement: [
        "discriminant",
        "cases"
      ],
      SwitchCase: [
        "test",
        "consequent"
      ],
      TaggedTemplateExpression: [
        "tag",
        "quasi"
      ],
      TemplateElement: [],
      TemplateLiteral: [
        "quasis",
        "expressions"
      ],
      ThisExpression: [],
      ThrowStatement: [
        "argument"
      ],
      TryStatement: [
        "block",
        "handler",
        "finalizer"
      ],
      UnaryExpression: [
        "argument"
      ],
      UpdateExpression: [
        "argument"
      ],
      VariableDeclaration: [
        "declarations"
      ],
      VariableDeclarator: [
        "id",
        "init"
      ],
      WhileStatement: [
        "test",
        "body"
      ],
      WithStatement: [
        "object",
        "body"
      ],
      YieldExpression: [
        "argument"
      ]
    };
  }
});

// node_modules/eslint-utils/node_modules/eslint-visitor-keys/lib/index.js
var require_lib = __commonJS({
  "node_modules/eslint-utils/node_modules/eslint-visitor-keys/lib/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    var KEYS = require_visitor_keys();
    var NODE_TYPES = Object.freeze(Object.keys(KEYS));
    for (const type of NODE_TYPES) {
      Object.freeze(KEYS[type]);
    }
    Object.freeze(KEYS);
    var KEY_BLACKLIST = /* @__PURE__ */ new Set([
      "parent",
      "leadingComments",
      "trailingComments"
    ]);
    function filterKey(key) {
      return !KEY_BLACKLIST.has(key) && key[0] !== "_";
    }
    module.exports = Object.freeze({
      /**
       * Visitor keys.
       * @type {{ [type: string]: string[] | undefined }}
       */
      KEYS,
      /**
       * Get visitor keys of a given node.
       * @param {Object} node The AST node to get keys.
       * @returns {string[]} Visitor keys of the node.
       */
      getKeys(node) {
        return Object.keys(node).filter(filterKey);
      },
      // Disable valid-jsdoc rule because it reports syntax error on the type of @returns.
      // eslint-disable-next-line valid-jsdoc
      /**
       * Make the union set with `KEYS` and given keys.
       * @param {Object} additionalKeys The additional keys.
       * @returns {{ [type: string]: string[] | undefined }} The union set.
       */
      unionWith(additionalKeys) {
        const retv = Object.assign({}, KEYS);
        for (const type of Object.keys(additionalKeys)) {
          if (retv.hasOwnProperty(type)) {
            const keys = new Set(additionalKeys[type]);
            for (const key of retv[type]) {
              keys.add(key);
            }
            retv[type] = Object.freeze(Array.from(keys));
          } else {
            retv[type] = Object.freeze(Array.from(additionalKeys[type]));
          }
        }
        return Object.freeze(retv);
      }
    });
  }
});

// src/eslint/presets/react.ts
init_esm_shims();

// src/eslint/configs/a11y.ts
init_esm_shims();
import jsxA11y from "eslint-plugin-jsx-a11y";
import globals from "globals";
function a11y() {
  return [
    {
      files: ["**/*.{js,mjs,cjs,jsx,mjsx,ts,tsx,mtsx}"],
      ...jsxA11y.flatConfigs.recommended,
      languageOptions: {
        ...jsxA11y.flatConfigs.recommended.languageOptions,
        globals: {
          ...globals.serviceworker,
          ...globals.browser
        }
      },
      settings: {
        "jsx-a11y": {
          components: {
            Input: "input",
            Button: "button",
            Link: "a",
            Label: "label",
            Select: "select",
            Textarea: "textarea"
          },
          attributes: {
            for: ["htmlFor", "for"]
          }
        }
      }
    }
  ];
}

// src/eslint/configs/react.ts
init_esm_shims();
import pluginQuery from "@tanstack/eslint-plugin-query";
import pluginReact from "eslint-plugin-react";
import pluginReactHooks from "eslint-plugin-react-hooks";
import pluginReactRefresh from "eslint-plugin-react-refresh";

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/index.js
init_esm_shims();

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/no-empty-effect.js
init_esm_shims();

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/util/react.js
init_esm_shims();

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/util/ast.js
init_esm_shims();

// node_modules/eslint-utils/index.mjs
init_esm_shims();
var import_eslint_visitor_keys = __toESM(require_lib(), 1);
function getInnermostScope(initialScope, node) {
  const location = node.range[0];
  let scope = initialScope;
  let found = false;
  do {
    found = false;
    for (const childScope of scope.childScopes) {
      const range = childScope.block.range;
      if (range[0] <= location && location < range[1]) {
        scope = childScope;
        found = true;
        break;
      }
    }
  } while (found);
  return scope;
}
function findVariable(initialScope, nameOrNode) {
  let name10 = "";
  let scope = initialScope;
  if (typeof nameOrNode === "string") {
    name10 = nameOrNode;
  } else {
    name10 = nameOrNode.name;
    scope = getInnermostScope(scope, nameOrNode);
  }
  while (scope != null) {
    const variable = scope.set.get(name10);
    if (variable != null) {
      return variable;
    }
    scope = scope.upper;
  }
  return null;
}
function negate0(token) {
  return !this(token);
}
function negate(f) {
  return negate0.bind(f);
}
function isPunctuatorTokenWithValue(token, value) {
  return token.type === "Punctuator" && token.value === value;
}
function isArrowToken(token) {
  return isPunctuatorTokenWithValue(token, "=>");
}
function isCommaToken(token) {
  return isPunctuatorTokenWithValue(token, ",");
}
function isSemicolonToken(token) {
  return isPunctuatorTokenWithValue(token, ";");
}
function isColonToken(token) {
  return isPunctuatorTokenWithValue(token, ":");
}
function isOpeningParenToken(token) {
  return isPunctuatorTokenWithValue(token, "(");
}
function isClosingParenToken(token) {
  return isPunctuatorTokenWithValue(token, ")");
}
function isOpeningBracketToken(token) {
  return isPunctuatorTokenWithValue(token, "[");
}
function isClosingBracketToken(token) {
  return isPunctuatorTokenWithValue(token, "]");
}
function isOpeningBraceToken(token) {
  return isPunctuatorTokenWithValue(token, "{");
}
function isClosingBraceToken(token) {
  return isPunctuatorTokenWithValue(token, "}");
}
function isCommentToken(token) {
  return ["Block", "Line", "Shebang"].includes(token.type);
}
var isNotArrowToken = negate(isArrowToken);
var isNotCommaToken = negate(isCommaToken);
var isNotSemicolonToken = negate(isSemicolonToken);
var isNotColonToken = negate(isColonToken);
var isNotOpeningParenToken = negate(isOpeningParenToken);
var isNotClosingParenToken = negate(isClosingParenToken);
var isNotOpeningBracketToken = negate(isOpeningBracketToken);
var isNotClosingBracketToken = negate(isClosingBracketToken);
var isNotOpeningBraceToken = negate(isOpeningBraceToken);
var isNotClosingBraceToken = negate(isClosingBraceToken);
var isNotCommentToken = negate(isCommentToken);
var globalObject = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
var builtinNames = Object.freeze(
  /* @__PURE__ */ new Set([
    "Array",
    "ArrayBuffer",
    "BigInt",
    "BigInt64Array",
    "BigUint64Array",
    "Boolean",
    "DataView",
    "Date",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "Float32Array",
    "Float64Array",
    "Function",
    "Infinity",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "isFinite",
    "isNaN",
    "isPrototypeOf",
    "JSON",
    "Map",
    "Math",
    "NaN",
    "Number",
    "Object",
    "parseFloat",
    "parseInt",
    "Promise",
    "Proxy",
    "Reflect",
    "RegExp",
    "Set",
    "String",
    "Symbol",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "undefined",
    "unescape",
    "WeakMap",
    "WeakSet"
  ])
);
var callAllowed = new Set(
  [
    Array.isArray,
    typeof BigInt === "function" ? BigInt : void 0,
    Boolean,
    Date,
    Date.parse,
    decodeURI,
    decodeURIComponent,
    encodeURI,
    encodeURIComponent,
    escape,
    isFinite,
    isNaN,
    isPrototypeOf,
    ...Object.getOwnPropertyNames(Math).map((k) => Math[k]).filter((f) => typeof f === "function"),
    Number,
    Number.isFinite,
    Number.isNaN,
    Number.parseFloat,
    Number.parseInt,
    Object,
    Object.entries,
    Object.is,
    Object.isExtensible,
    Object.isFrozen,
    Object.isSealed,
    Object.keys,
    Object.values,
    parseFloat,
    parseInt,
    RegExp,
    String,
    String.fromCharCode,
    String.fromCodePoint,
    String.raw,
    Symbol.for,
    Symbol.keyFor,
    unescape
  ].filter((f) => typeof f === "function")
);
var callPassThrough = /* @__PURE__ */ new Set([
  Object.freeze,
  Object.preventExtensions,
  Object.seal
]);
function getPropertyDescriptor(object, name10) {
  let x = object;
  while ((typeof x === "object" || typeof x === "function") && x !== null) {
    const d = Object.getOwnPropertyDescriptor(x, name10);
    if (d) {
      return d;
    }
    x = Object.getPrototypeOf(x);
  }
  return null;
}
function isGetter(object, name10) {
  const d = getPropertyDescriptor(object, name10);
  return d != null && d.get != null;
}
function getElementValues(nodeList, initialScope) {
  const valueList = [];
  for (let i = 0; i < nodeList.length; ++i) {
    const elementNode = nodeList[i];
    if (elementNode == null) {
      valueList.length = i + 1;
    } else if (elementNode.type === "SpreadElement") {
      const argument = getStaticValueR(elementNode.argument, initialScope);
      if (argument == null) {
        return null;
      }
      valueList.push(...argument.value);
    } else {
      const element = getStaticValueR(elementNode, initialScope);
      if (element == null) {
        return null;
      }
      valueList.push(element.value);
    }
  }
  return valueList;
}
var operations = Object.freeze({
  ArrayExpression(node, initialScope) {
    const elements = getElementValues(node.elements, initialScope);
    return elements != null ? { value: elements } : null;
  },
  AssignmentExpression(node, initialScope) {
    if (node.operator === "=") {
      return getStaticValueR(node.right, initialScope);
    }
    return null;
  },
  //eslint-disable-next-line complexity
  BinaryExpression(node, initialScope) {
    if (node.operator === "in" || node.operator === "instanceof") {
      return null;
    }
    const left = getStaticValueR(node.left, initialScope);
    const right = getStaticValueR(node.right, initialScope);
    if (left != null && right != null) {
      switch (node.operator) {
        case "==":
          return { value: left.value == right.value };
        //eslint-disable-line eqeqeq
        case "!=":
          return { value: left.value != right.value };
        //eslint-disable-line eqeqeq
        case "===":
          return { value: left.value === right.value };
        case "!==":
          return { value: left.value !== right.value };
        case "<":
          return { value: left.value < right.value };
        case "<=":
          return { value: left.value <= right.value };
        case ">":
          return { value: left.value > right.value };
        case ">=":
          return { value: left.value >= right.value };
        case "<<":
          return { value: left.value << right.value };
        case ">>":
          return { value: left.value >> right.value };
        case ">>>":
          return { value: left.value >>> right.value };
        case "+":
          return { value: left.value + right.value };
        case "-":
          return { value: left.value - right.value };
        case "*":
          return { value: left.value * right.value };
        case "/":
          return { value: left.value / right.value };
        case "%":
          return { value: left.value % right.value };
        case "**":
          return { value: Math.pow(left.value, right.value) };
        case "|":
          return { value: left.value | right.value };
        case "^":
          return { value: left.value ^ right.value };
        case "&":
          return { value: left.value & right.value };
      }
    }
    return null;
  },
  CallExpression(node, initialScope) {
    const calleeNode = node.callee;
    const args = getElementValues(node.arguments, initialScope);
    if (args != null) {
      if (calleeNode.type === "MemberExpression") {
        if (calleeNode.property.type === "PrivateIdentifier") {
          return null;
        }
        const object = getStaticValueR(calleeNode.object, initialScope);
        if (object != null) {
          if (object.value == null && (object.optional || node.optional)) {
            return { value: void 0, optional: true };
          }
          const property = getStaticPropertyNameValue(
            calleeNode,
            initialScope
          );
          if (property != null) {
            const receiver = object.value;
            const methodName = property.value;
            if (callAllowed.has(receiver[methodName])) {
              return { value: receiver[methodName](...args) };
            }
            if (callPassThrough.has(receiver[methodName])) {
              return { value: args[0] };
            }
          }
        }
      } else {
        const callee = getStaticValueR(calleeNode, initialScope);
        if (callee != null) {
          if (callee.value == null && node.optional) {
            return { value: void 0, optional: true };
          }
          const func = callee.value;
          if (callAllowed.has(func)) {
            return { value: func(...args) };
          }
          if (callPassThrough.has(func)) {
            return { value: args[0] };
          }
        }
      }
    }
    return null;
  },
  ConditionalExpression(node, initialScope) {
    const test = getStaticValueR(node.test, initialScope);
    if (test != null) {
      return test.value ? getStaticValueR(node.consequent, initialScope) : getStaticValueR(node.alternate, initialScope);
    }
    return null;
  },
  ExpressionStatement(node, initialScope) {
    return getStaticValueR(node.expression, initialScope);
  },
  Identifier(node, initialScope) {
    if (initialScope != null) {
      const variable = findVariable(initialScope, node);
      if (variable != null && variable.defs.length === 0 && builtinNames.has(variable.name) && variable.name in globalObject) {
        return { value: globalObject[variable.name] };
      }
      if (variable != null && variable.defs.length === 1) {
        const def = variable.defs[0];
        if (def.parent && def.parent.kind === "const" && // TODO(mysticatea): don't support destructuring here.
        def.node.id.type === "Identifier") {
          return getStaticValueR(def.node.init, initialScope);
        }
      }
    }
    return null;
  },
  Literal(node) {
    if ((node.regex != null || node.bigint != null) && node.value == null) {
      return null;
    }
    return { value: node.value };
  },
  LogicalExpression(node, initialScope) {
    const left = getStaticValueR(node.left, initialScope);
    if (left != null) {
      if (node.operator === "||" && Boolean(left.value) === true || node.operator === "&&" && Boolean(left.value) === false || node.operator === "??" && left.value != null) {
        return left;
      }
      const right = getStaticValueR(node.right, initialScope);
      if (right != null) {
        return right;
      }
    }
    return null;
  },
  MemberExpression(node, initialScope) {
    if (node.property.type === "PrivateIdentifier") {
      return null;
    }
    const object = getStaticValueR(node.object, initialScope);
    if (object != null) {
      if (object.value == null && (object.optional || node.optional)) {
        return { value: void 0, optional: true };
      }
      const property = getStaticPropertyNameValue(node, initialScope);
      if (property != null && !isGetter(object.value, property.value)) {
        return { value: object.value[property.value] };
      }
    }
    return null;
  },
  ChainExpression(node, initialScope) {
    const expression = getStaticValueR(node.expression, initialScope);
    if (expression != null) {
      return { value: expression.value };
    }
    return null;
  },
  NewExpression(node, initialScope) {
    const callee = getStaticValueR(node.callee, initialScope);
    const args = getElementValues(node.arguments, initialScope);
    if (callee != null && args != null) {
      const Func = callee.value;
      if (callAllowed.has(Func)) {
        return { value: new Func(...args) };
      }
    }
    return null;
  },
  ObjectExpression(node, initialScope) {
    const object = {};
    for (const propertyNode of node.properties) {
      if (propertyNode.type === "Property") {
        if (propertyNode.kind !== "init") {
          return null;
        }
        const key = getStaticPropertyNameValue(
          propertyNode,
          initialScope
        );
        const value = getStaticValueR(propertyNode.value, initialScope);
        if (key == null || value == null) {
          return null;
        }
        object[key.value] = value.value;
      } else if (propertyNode.type === "SpreadElement" || propertyNode.type === "ExperimentalSpreadProperty") {
        const argument = getStaticValueR(
          propertyNode.argument,
          initialScope
        );
        if (argument == null) {
          return null;
        }
        Object.assign(object, argument.value);
      } else {
        return null;
      }
    }
    return { value: object };
  },
  SequenceExpression(node, initialScope) {
    const last = node.expressions[node.expressions.length - 1];
    return getStaticValueR(last, initialScope);
  },
  TaggedTemplateExpression(node, initialScope) {
    const tag = getStaticValueR(node.tag, initialScope);
    const expressions = getElementValues(
      node.quasi.expressions,
      initialScope
    );
    if (tag != null && expressions != null) {
      const func = tag.value;
      const strings = node.quasi.quasis.map((q) => q.value.cooked);
      strings.raw = node.quasi.quasis.map((q) => q.value.raw);
      if (func === String.raw) {
        return { value: func(strings, ...expressions) };
      }
    }
    return null;
  },
  TemplateLiteral(node, initialScope) {
    const expressions = getElementValues(node.expressions, initialScope);
    if (expressions != null) {
      let value = node.quasis[0].value.cooked;
      for (let i = 0; i < expressions.length; ++i) {
        value += expressions[i];
        value += node.quasis[i + 1].value.cooked;
      }
      return { value };
    }
    return null;
  },
  UnaryExpression(node, initialScope) {
    if (node.operator === "delete") {
      return null;
    }
    if (node.operator === "void") {
      return { value: void 0 };
    }
    const arg = getStaticValueR(node.argument, initialScope);
    if (arg != null) {
      switch (node.operator) {
        case "-":
          return { value: -arg.value };
        case "+":
          return { value: +arg.value };
        //eslint-disable-line no-implicit-coercion
        case "!":
          return { value: !arg.value };
        case "~":
          return { value: ~arg.value };
        case "typeof":
          return { value: typeof arg.value };
      }
    }
    return null;
  }
});
function getStaticValueR(node, initialScope) {
  if (node != null && Object.hasOwnProperty.call(operations, node.type)) {
    return operations[node.type](node, initialScope);
  }
  return null;
}
function getStaticPropertyNameValue(node, initialScope) {
  const nameNode = node.type === "Property" ? node.key : node.property;
  if (node.computed) {
    return getStaticValueR(nameNode, initialScope);
  }
  if (nameNode.type === "Identifier") {
    return { value: nameNode.name };
  }
  if (nameNode.type === "Literal") {
    if (nameNode.bigint) {
      return { value: nameNode.bigint };
    }
    return { value: String(nameNode.value) };
  }
  return null;
}
function getStaticValue(node, initialScope = null) {
  try {
    return getStaticValueR(node, initialScope);
  } catch (_error) {
    return null;
  }
}
function getStringIfConstant(node, initialScope = null) {
  if (node && node.type === "Literal" && node.value === null) {
    if (node.regex) {
      return `/${node.regex.pattern}/${node.regex.flags}`;
    }
    if (node.bigint) {
      return node.bigint;
    }
  }
  const evaluated = getStaticValue(node, initialScope);
  return evaluated && String(evaluated.value);
}
function getPropertyName(node, initialScope) {
  switch (node.type) {
    case "MemberExpression":
      if (node.computed) {
        return getStringIfConstant(node.property, initialScope);
      }
      if (node.property.type === "PrivateIdentifier") {
        return null;
      }
      return node.property.name;
    case "Property":
    case "MethodDefinition":
    case "PropertyDefinition":
      if (node.computed) {
        return getStringIfConstant(node.key, initialScope);
      }
      if (node.key.type === "Literal") {
        return String(node.key.value);
      }
      if (node.key.type === "PrivateIdentifier") {
        return null;
      }
      return node.key.name;
  }
  return null;
}
var typeConversionBinaryOps = Object.freeze(
  /* @__PURE__ */ new Set([
    "==",
    "!=",
    "<",
    "<=",
    ">",
    ">=",
    "<<",
    ">>",
    ">>>",
    "+",
    "-",
    "*",
    "/",
    "%",
    "|",
    "^",
    "&",
    "in"
  ])
);
var typeConversionUnaryOps = Object.freeze(/* @__PURE__ */ new Set(["-", "+", "!", "~"]));
function isNode(x) {
  return x !== null && typeof x === "object" && typeof x.type === "string";
}
var visitor = Object.freeze(
  Object.assign(/* @__PURE__ */ Object.create(null), {
    $visit(node, options, visitorKeys) {
      const { type } = node;
      if (typeof this[type] === "function") {
        return this[type](node, options, visitorKeys);
      }
      return this.$visitChildren(node, options, visitorKeys);
    },
    $visitChildren(node, options, visitorKeys) {
      const { type } = node;
      for (const key of visitorKeys[type] || import_eslint_visitor_keys.default.getKeys(node)) {
        const value = node[key];
        if (Array.isArray(value)) {
          for (const element of value) {
            if (isNode(element) && this.$visit(element, options, visitorKeys)) {
              return true;
            }
          }
        } else if (isNode(value) && this.$visit(value, options, visitorKeys)) {
          return true;
        }
      }
      return false;
    },
    ArrowFunctionExpression() {
      return false;
    },
    AssignmentExpression() {
      return true;
    },
    AwaitExpression() {
      return true;
    },
    BinaryExpression(node, options, visitorKeys) {
      if (options.considerImplicitTypeConversion && typeConversionBinaryOps.has(node.operator) && (node.left.type !== "Literal" || node.right.type !== "Literal")) {
        return true;
      }
      return this.$visitChildren(node, options, visitorKeys);
    },
    CallExpression() {
      return true;
    },
    FunctionExpression() {
      return false;
    },
    ImportExpression() {
      return true;
    },
    MemberExpression(node, options, visitorKeys) {
      if (options.considerGetters) {
        return true;
      }
      if (options.considerImplicitTypeConversion && node.computed && node.property.type !== "Literal") {
        return true;
      }
      return this.$visitChildren(node, options, visitorKeys);
    },
    MethodDefinition(node, options, visitorKeys) {
      if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
        return true;
      }
      return this.$visitChildren(node, options, visitorKeys);
    },
    NewExpression() {
      return true;
    },
    Property(node, options, visitorKeys) {
      if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
        return true;
      }
      return this.$visitChildren(node, options, visitorKeys);
    },
    PropertyDefinition(node, options, visitorKeys) {
      if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
        return true;
      }
      return this.$visitChildren(node, options, visitorKeys);
    },
    UnaryExpression(node, options, visitorKeys) {
      if (node.operator === "delete") {
        return true;
      }
      if (options.considerImplicitTypeConversion && typeConversionUnaryOps.has(node.operator) && node.argument.type !== "Literal") {
        return true;
      }
      return this.$visitChildren(node, options, visitorKeys);
    },
    UpdateExpression() {
      return true;
    },
    YieldExpression() {
      return true;
    }
  })
);
var IMPORT_TYPE = /^(?:Import|Export(?:All|Default|Named))Declaration$/u;
var has = Function.call.bind(Object.hasOwnProperty);
var READ = Symbol("read");
var CALL = Symbol("call");
var CONSTRUCT = Symbol("construct");
var ESM = Symbol("esm");
var requireCall = { require: { [CALL]: true } };
function isModifiedGlobal(variable) {
  return variable == null || variable.defs.length !== 0 || variable.references.some((r) => r.isWrite());
}
function isPassThrough(node) {
  const parent = node.parent;
  switch (parent && parent.type) {
    case "ConditionalExpression":
      return parent.consequent === node || parent.alternate === node;
    case "LogicalExpression":
      return true;
    case "SequenceExpression":
      return parent.expressions[parent.expressions.length - 1] === node;
    case "ChainExpression":
      return true;
    default:
      return false;
  }
}
var ReferenceTracker = class {
  /**
   * Initialize this tracker.
   * @param {Scope} globalScope The global scope.
   * @param {object} [options] The options.
   * @param {"legacy"|"strict"} [options.mode="strict"] The mode to determine the ImportDeclaration's behavior for CJS modules.
   * @param {string[]} [options.globalObjectNames=["global","globalThis","self","window"]] The variable names for Global Object.
   */
  constructor(globalScope, {
    mode = "strict",
    globalObjectNames = ["global", "globalThis", "self", "window"]
  } = {}) {
    this.variableStack = [];
    this.globalScope = globalScope;
    this.mode = mode;
    this.globalObjectNames = globalObjectNames.slice(0);
  }
  /**
   * Iterate the references of global variables.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *iterateGlobalReferences(traceMap) {
    for (const key of Object.keys(traceMap)) {
      const nextTraceMap = traceMap[key];
      const path = [key];
      const variable = this.globalScope.set.get(key);
      if (isModifiedGlobal(variable)) {
        continue;
      }
      yield* this._iterateVariableReferences(
        variable,
        path,
        nextTraceMap,
        true
      );
    }
    for (const key of this.globalObjectNames) {
      const path = [];
      const variable = this.globalScope.set.get(key);
      if (isModifiedGlobal(variable)) {
        continue;
      }
      yield* this._iterateVariableReferences(
        variable,
        path,
        traceMap,
        false
      );
    }
  }
  /**
   * Iterate the references of CommonJS modules.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *iterateCjsReferences(traceMap) {
    for (const { node } of this.iterateGlobalReferences(requireCall)) {
      const key = getStringIfConstant(node.arguments[0]);
      if (key == null || !has(traceMap, key)) {
        continue;
      }
      const nextTraceMap = traceMap[key];
      const path = [key];
      if (nextTraceMap[READ]) {
        yield {
          node,
          path,
          type: READ,
          info: nextTraceMap[READ]
        };
      }
      yield* this._iteratePropertyReferences(node, path, nextTraceMap);
    }
  }
  /**
   * Iterate the references of ES modules.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *iterateEsmReferences(traceMap) {
    const programNode = this.globalScope.block;
    for (const node of programNode.body) {
      if (!IMPORT_TYPE.test(node.type) || node.source == null) {
        continue;
      }
      const moduleId = node.source.value;
      if (!has(traceMap, moduleId)) {
        continue;
      }
      const nextTraceMap = traceMap[moduleId];
      const path = [moduleId];
      if (nextTraceMap[READ]) {
        yield { node, path, type: READ, info: nextTraceMap[READ] };
      }
      if (node.type === "ExportAllDeclaration") {
        for (const key of Object.keys(nextTraceMap)) {
          const exportTraceMap = nextTraceMap[key];
          if (exportTraceMap[READ]) {
            yield {
              node,
              path: path.concat(key),
              type: READ,
              info: exportTraceMap[READ]
            };
          }
        }
      } else {
        for (const specifier of node.specifiers) {
          const esm = has(nextTraceMap, ESM);
          const it = this._iterateImportReferences(
            specifier,
            path,
            esm ? nextTraceMap : this.mode === "legacy" ? { default: nextTraceMap, ...nextTraceMap } : { default: nextTraceMap }
          );
          if (esm) {
            yield* it;
          } else {
            for (const report of it) {
              report.path = report.path.filter(exceptDefault);
              if (report.path.length >= 2 || report.type !== READ) {
                yield report;
              }
            }
          }
        }
      }
    }
  }
  /**
   * Iterate the references for a given variable.
   * @param {Variable} variable The variable to iterate that references.
   * @param {string[]} path The current path.
   * @param {object} traceMap The trace map.
   * @param {boolean} shouldReport = The flag to report those references.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *_iterateVariableReferences(variable, path, traceMap, shouldReport) {
    if (this.variableStack.includes(variable)) {
      return;
    }
    this.variableStack.push(variable);
    try {
      for (const reference of variable.references) {
        if (!reference.isRead()) {
          continue;
        }
        const node = reference.identifier;
        if (shouldReport && traceMap[READ]) {
          yield { node, path, type: READ, info: traceMap[READ] };
        }
        yield* this._iteratePropertyReferences(node, path, traceMap);
      }
    } finally {
      this.variableStack.pop();
    }
  }
  /**
   * Iterate the references for a given AST node.
   * @param rootNode The AST node to iterate references.
   * @param {string[]} path The current path.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  //eslint-disable-next-line complexity
  *_iteratePropertyReferences(rootNode, path, traceMap) {
    let node = rootNode;
    while (isPassThrough(node)) {
      node = node.parent;
    }
    const parent = node.parent;
    if (parent.type === "MemberExpression") {
      if (parent.object === node) {
        const key = getPropertyName(parent);
        if (key == null || !has(traceMap, key)) {
          return;
        }
        path = path.concat(key);
        const nextTraceMap = traceMap[key];
        if (nextTraceMap[READ]) {
          yield {
            node: parent,
            path,
            type: READ,
            info: nextTraceMap[READ]
          };
        }
        yield* this._iteratePropertyReferences(
          parent,
          path,
          nextTraceMap
        );
      }
      return;
    }
    if (parent.type === "CallExpression") {
      if (parent.callee === node && traceMap[CALL]) {
        yield { node: parent, path, type: CALL, info: traceMap[CALL] };
      }
      return;
    }
    if (parent.type === "NewExpression") {
      if (parent.callee === node && traceMap[CONSTRUCT]) {
        yield {
          node: parent,
          path,
          type: CONSTRUCT,
          info: traceMap[CONSTRUCT]
        };
      }
      return;
    }
    if (parent.type === "AssignmentExpression") {
      if (parent.right === node) {
        yield* this._iterateLhsReferences(parent.left, path, traceMap);
        yield* this._iteratePropertyReferences(parent, path, traceMap);
      }
      return;
    }
    if (parent.type === "AssignmentPattern") {
      if (parent.right === node) {
        yield* this._iterateLhsReferences(parent.left, path, traceMap);
      }
      return;
    }
    if (parent.type === "VariableDeclarator") {
      if (parent.init === node) {
        yield* this._iterateLhsReferences(parent.id, path, traceMap);
      }
    }
  }
  /**
   * Iterate the references for a given Pattern node.
   * @param {Node} patternNode The Pattern node to iterate references.
   * @param {string[]} path The current path.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *_iterateLhsReferences(patternNode, path, traceMap) {
    if (patternNode.type === "Identifier") {
      const variable = findVariable(this.globalScope, patternNode);
      if (variable != null) {
        yield* this._iterateVariableReferences(
          variable,
          path,
          traceMap,
          false
        );
      }
      return;
    }
    if (patternNode.type === "ObjectPattern") {
      for (const property of patternNode.properties) {
        const key = getPropertyName(property);
        if (key == null || !has(traceMap, key)) {
          continue;
        }
        const nextPath = path.concat(key);
        const nextTraceMap = traceMap[key];
        if (nextTraceMap[READ]) {
          yield {
            node: property,
            path: nextPath,
            type: READ,
            info: nextTraceMap[READ]
          };
        }
        yield* this._iterateLhsReferences(
          property.value,
          nextPath,
          nextTraceMap
        );
      }
      return;
    }
    if (patternNode.type === "AssignmentPattern") {
      yield* this._iterateLhsReferences(patternNode.left, path, traceMap);
    }
  }
  /**
   * Iterate the references for a given ModuleSpecifier node.
   * @param {Node} specifierNode The ModuleSpecifier node to iterate references.
   * @param {string[]} path The current path.
   * @param {object} traceMap The trace map.
   * @returns {IterableIterator<{node:Node,path:string[],type:symbol,info:any}>} The iterator to iterate references.
   */
  *_iterateImportReferences(specifierNode, path, traceMap) {
    const type = specifierNode.type;
    if (type === "ImportSpecifier" || type === "ImportDefaultSpecifier") {
      const key = type === "ImportDefaultSpecifier" ? "default" : specifierNode.imported.name;
      if (!has(traceMap, key)) {
        return;
      }
      path = path.concat(key);
      const nextTraceMap = traceMap[key];
      if (nextTraceMap[READ]) {
        yield {
          node: specifierNode,
          path,
          type: READ,
          info: nextTraceMap[READ]
        };
      }
      yield* this._iterateVariableReferences(
        findVariable(this.globalScope, specifierNode.local),
        path,
        nextTraceMap,
        false
      );
      return;
    }
    if (type === "ImportNamespaceSpecifier") {
      yield* this._iterateVariableReferences(
        findVariable(this.globalScope, specifierNode.local),
        path,
        traceMap,
        false
      );
      return;
    }
    if (type === "ExportSpecifier") {
      const key = specifierNode.local.name;
      if (!has(traceMap, key)) {
        return;
      }
      path = path.concat(key);
      const nextTraceMap = traceMap[key];
      if (nextTraceMap[READ]) {
        yield {
          node: specifierNode,
          path,
          type: READ,
          info: nextTraceMap[READ]
        };
      }
    }
  }
};
ReferenceTracker.READ = READ;
ReferenceTracker.CALL = CALL;
ReferenceTracker.CONSTRUCT = CONSTRUCT;
ReferenceTracker.ESM = ESM;
function exceptDefault(name10, index) {
  return !(index === 1 && name10 === "default");
}

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/util/ast.js
var traverse = (context, node, visit, visited = /* @__PURE__ */ new Set()) => {
  if (visited.has(node)) {
    return;
  }
  visited.add(node);
  visit(node);
  (context.sourceCode.visitorKeys[node.type] || []).map((key) => node[key]).filter(Boolean).flatMap((child) => Array.isArray(child) ? child : [child]).filter(Boolean).filter((child) => typeof child.type === "string").forEach((child) => traverse(context, child, visit, visited));
};
var findDownstreamNodes = (context, topNode, type) => {
  const nodes = [];
  traverse(context, topNode, (node) => {
    if (node.type === type) {
      nodes.push(node);
    }
  });
  return nodes;
};
var getUpstreamVariables = (context, variable, filter, visited = /* @__PURE__ */ new Set()) => {
  if (visited.has(variable)) {
    return [];
  }
  visited.add(variable);
  const upstreamVariables = variable.defs.filter((def) => !!def.node.init).filter((def) => filter(def.node)).flatMap((def) => getDownstreamRefs(context, def.node.init)).map((ref) => ref.resolved).filter(Boolean).flatMap(
    (variable2) => getUpstreamVariables(context, variable2, filter, visited)
  );
  return upstreamVariables.length === 0 ? [variable] : upstreamVariables;
};
var getDownstreamRefs = (context, node) => findDownstreamNodes(context, node, "Identifier").map((identifier) => getRef(context, identifier)).filter(Boolean);
var getRef = (context, identifier) => findVariable(
  context.sourceCode.getScope(identifier),
  identifier
)?.references.find((ref) => ref.identifier === identifier);
var getCallExpr = (ref, current = ref.identifier.parent) => {
  if (current.type === "CallExpression") {
    let node = ref.identifier;
    while (node.parent.type === "MemberExpression") {
      node = node.parent;
    }
    if (current.callee === node) {
      return current;
    }
  }
  if (current.type === "MemberExpression") {
    return getCallExpr(ref, current.parent);
  }
  return void 0;
};
var isIIFE = (node) => node.type === "CallExpression" && (node.callee.type === "ArrowFunctionExpression" || node.callee.type === "FunctionExpression");

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/util/react.js
var isReactFunctionalComponent = (node) => (node.type === "FunctionDeclaration" || node.type === "VariableDeclarator" && (node.init.type === "ArrowFunctionExpression" || node.init.type === "CallExpression")) && node.id.type === "Identifier" && node.id.name[0].toUpperCase() === node.id.name[0];
var isReactFunctionalHOC = (node) => node.type === "VariableDeclarator" && node.init && node.init.type === "CallExpression" && node.init.callee.type === "Identifier" && !["memo", "forwardRef"].includes(node.init.callee.name) && node.init.arguments.length > 0 && (node.init.arguments[0].type === "ArrowFunctionExpression" || node.init.arguments[0].type === "FunctionExpression") && node.id.type === "Identifier" && node.id.name[0].toUpperCase() === node.id.name[0];
var isCustomHook = (node) => (node.type === "FunctionDeclaration" || node.type === "VariableDeclarator" && node.init && (node.init.type === "ArrowFunctionExpression" || node.init.type === "FunctionExpression")) && node.id.type === "Identifier" && node.id.name.startsWith("use") && node.id.name[3] === node.id.name[3].toUpperCase();
var isUseState = (node) => node.type === "VariableDeclarator" && node.init && node.init.type === "CallExpression" && node.init.callee.name === "useState" && node.id.type === "ArrayPattern" && // Not sure its usecase, but may just have the setter
(node.id.elements.length === 1 || node.id.elements.length === 2) && node.id.elements.every((el) => {
  return !el || el.type === "Identifier";
});
var isUseRef = (node) => node.type === "VariableDeclarator" && node.init && node.init.type === "CallExpression" && node.init.callee.name === "useRef" && node.id.type === "Identifier";
var isUseEffect = (node) => node.type === "CallExpression" && (node.callee.type === "Identifier" && (node.callee.name === "useEffect" || node.callee.name === "useLayoutEffect") || node.callee.type === "MemberExpression" && node.callee.object.name === "React" && (node.callee.property.name === "useEffect" || node.callee.property.name === "useLayoutEffect"));
var getEffectFn = (node) => {
  if (!isUseEffect(node) || node.arguments.length < 1) {
    return void 0;
  }
  const effectFn = node.arguments[0];
  if (effectFn.type !== "ArrowFunctionExpression" && effectFn.type !== "FunctionExpression") {
    return void 0;
  }
  return effectFn;
};
var getEffectFnRefs = (context, node) => {
  const effectFn = getEffectFn(node);
  if (!effectFn) {
    return null;
  }
  return getDownstreamRefs(context, effectFn);
};
function getDependenciesRefs(context, node) {
  if (!isUseEffect(node) || node.arguments.length < 2) {
    return void 0;
  }
  const depsArr = node.arguments[1];
  if (depsArr.type !== "ArrayExpression") {
    return void 0;
  }
  return getDownstreamRefs(context, depsArr);
}
var isFnRef = (ref) => getCallExpr(ref) !== void 0;
var isStateSetter = (context, ref) => isFnRef(ref) && getUpstreamReactVariables(context, ref.resolved).notEmptyEvery(
  (variable) => isState(variable)
);
var isPropCallback = (context, ref) => isFnRef(ref) && getUpstreamReactVariables(context, ref.resolved).notEmptyEvery(
  (variable) => isProp(variable)
);
var isState = (variable) => variable.defs.some((def) => isUseState(def.node));
var isRef = (variable) => variable.defs.some((def) => isUseRef(def.node));
var isProp = (variable) => variable.defs.some(
  (def) => def.type === "Parameter" && (isReactFunctionalComponent(getDeclNode(def.node)) || isCustomHook(getDeclNode(def.node)))
);
var isHOCProp = (variable) => variable.defs.some(
  (def) => def.type === "Parameter" && isReactFunctionalHOC(getDeclNode(def.node))
);
var getDeclNode = (node) => node.type === "ArrowFunctionExpression" ? node.parent.type === "CallExpression" ? node.parent.parent : node.parent : node;
var getUseStateNode = (context, ref) => {
  return getUpstreamReactVariables(context, ref.resolved).find((variable) => isState(variable))?.defs.find((def) => isUseState(def.node))?.node;
};
var isDirectCall = (node) => {
  if (!node) {
    return false;
  } else if ((node.type === "ArrowFunctionExpression" || node.type === "FunctionExpression") && !isIIFE(node.parent)) {
    return isUseEffect(node.parent);
  } else {
    return isDirectCall(node.parent);
  }
};
var findPropUsedToResetAllState = (context, effectFnRefs, depsRefs, useEffectNode) => {
  const stateSetterRefs = effectFnRefs.filter(
    (ref) => isStateSetter(context, ref)
  );
  const isAllStateReset = stateSetterRefs.length > 0 && stateSetterRefs.every((ref) => isSetStateToInitialValue(context, ref)) && stateSetterRefs.length === countUseStates(context, findContainingNode(useEffectNode));
  return isAllStateReset ? depsRefs.find((ref) => isProp(ref.resolved)) : void 0;
};
var isSetStateToInitialValue = (context, setterRef) => {
  const setStateToValue = getCallExpr(setterRef).arguments[0];
  const stateInitialValue = getUseStateNode(context, setterRef).init.arguments[0];
  const isUndefined = (node) => node === void 0 || node.name === "undefined";
  if (isUndefined(setStateToValue) && isUndefined(stateInitialValue)) {
    return true;
  }
  if (setStateToValue === null && stateInitialValue === null) {
    return true;
  } else if (setStateToValue && !stateInitialValue || !setStateToValue && stateInitialValue) {
    return false;
  }
  return context.sourceCode.getText(setStateToValue) === context.sourceCode.getText(stateInitialValue);
};
var countUseStates = (context, componentNode) => {
  let count = 0;
  traverse(context, componentNode, (node) => {
    if (isUseState(node)) {
      count++;
    }
  });
  return count;
};
var countCalls = (ref) => ref.resolved.references.filter(
  (ref2) => ref2.identifier.parent.type === "CallExpression"
).length;
var findContainingNode = (node) => {
  if (!node) {
    return void 0;
  } else if (isReactFunctionalComponent(node) || isReactFunctionalHOC(node) || isCustomHook(node)) {
    return node;
  } else {
    return findContainingNode(node.parent);
  }
};
var getUpstreamReactVariables = (context, variable) => getUpstreamVariables(
  context,
  variable,
  // Stop at the *usage* of `useState` - don't go up to the `useState` variable.
  // Not needed for props - they don't go "too far".
  // We could remove this and check for the `useState` variable instead,
  // but then all our tests need to import it so we can traverse up to it.
  // And would need to change `getUseStateNode()` too?
  // TODO: Could probably organize these filters better.
  (node) => !isUseState(node)
).filter(
  (variable2) => isProp(variable2) || variable2.defs.every((def) => def.type !== "Parameter")
);

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/no-empty-effect.js
var name = "no-empty-effect";
var messages = {
  avoidEmptyEffect: "avoidEmptyEffect"
};
var rule = {
  meta: {
    type: "suggestion",
    docs: {
      description: "Disallow empty React effects."
    },
    schema: [],
    messages: {
      [messages.avoidEmptyEffect]: "This effect is empty and could be removed."
    }
  },
  create: (context) => ({
    CallExpression: (node) => {
      if (!isUseEffect(node)) return;
      const effectFnRefs = getEffectFnRefs(context, node);
      if (effectFnRefs?.length === 0) {
        context.report({
          node,
          messageId: messages.avoidEmptyEffect
        });
      }
    }
  })
};

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/no-reset-all-state-when-a-prop-changes.js
init_esm_shims();
var name2 = "no-reset-all-state-when-a-prop-changes";
var messages2 = {
  avoidResettingAllStateWhenAPropChanges: "avoidResettingAllStateWhenAPropChanges"
};
var rule2 = {
  meta: {
    type: "suggestion",
    docs: {
      description: "Disallow resetting all state in an effect when a prop changes.",
      url: "https://react.dev/learn/you-might-not-need-an-effect#resetting-all-state-when-a-prop-changes"
    },
    schema: [],
    messages: {
      [messages2.avoidResettingAllStateWhenAPropChanges]: 'Avoid resetting all state when a prop changes. If "{{prop}}" is a key, pass it as `key` instead so React will reset the component.'
    }
  },
  create: (context) => ({
    CallExpression: (node) => {
      if (!isUseEffect(node)) return;
      const effectFnRefs = getEffectFnRefs(context, node);
      const depsRefs = getDependenciesRefs(context, node);
      if (!effectFnRefs || !depsRefs) return;
      const propUsedToResetAllState = findPropUsedToResetAllState(
        context,
        effectFnRefs,
        depsRefs,
        node
      );
      if (propUsedToResetAllState) {
        context.report({
          node,
          messageId: messages2.avoidResettingAllStateWhenAPropChanges,
          data: { prop: propUsedToResetAllState.identifier.name }
        });
      }
    }
  })
};

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/no-event-handler.js
init_esm_shims();
var name3 = "no-event-handler";
var messages3 = {
  avoidEventHandler: "avoidEventHandler"
};
var rule3 = {
  meta: {
    type: "suggestion",
    docs: {
      description: "Disallow using state and an effect as an event handler.",
      url: "https://react.dev/learn/you-might-not-need-an-effect#sharing-logic-between-event-handlers"
    },
    schema: [],
    messages: {
      [messages3.avoidEventHandler]: "Avoid using state and effects as an event handler. Instead, call the event handling code directly when the event occurs."
    }
  },
  create: (context) => ({
    CallExpression: (node) => {
      if (!isUseEffect(node)) return;
      const effectFnRefs = getEffectFnRefs(context, node);
      const depsRefs = getDependenciesRefs(context, node);
      if (!effectFnRefs || !depsRefs) return;
      findDownstreamNodes(context, node, "IfStatement").filter((ifNode) => !ifNode.alternate).filter(
        (ifNode) => getDownstreamRefs(context, ifNode.test).flatMap((ref) => getUpstreamReactVariables(context, ref.resolved)).notEmptyEvery((variable) => isState(variable))
      ).forEach((ifNode) => {
        context.report({
          node: ifNode.test,
          messageId: messages3.avoidEventHandler
        });
      });
    }
  })
};

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/no-pass-live-state-to-parent.js
init_esm_shims();
var name4 = "no-pass-live-state-to-parent";
var messages4 = {
  avoidPassingLiveStateToParent: "avoidPassingLiveStateToParent"
};
var rule4 = {
  meta: {
    type: "suggestion",
    docs: {
      description: "Disallow passing live state to parent components in an effect.",
      url: "https://react.dev/learn/you-might-not-need-an-effect#notifying-parent-components-about-state-changes"
    },
    schema: [],
    messages: {
      [messages4.avoidPassingLiveStateToParent]: "Avoid passing live state to parents in an effect. Instead, lift the state to the parent and pass it down to the child as a prop."
    }
  },
  create: (context) => ({
    CallExpression: (node) => {
      if (!isUseEffect(node)) return;
      const effectFnRefs = getEffectFnRefs(context, node);
      const depsRefs = getDependenciesRefs(context, node);
      if (!effectFnRefs || !depsRefs) return;
      effectFnRefs.filter(isFnRef).filter((ref) => isDirectCall(ref.identifier)).filter(
        (ref) => isPropCallback(context, ref) && !isHOCProp(ref.resolved)
      ).forEach((ref) => {
        const callExpr = getCallExpr(ref);
        const argsUpstreamVariables = callExpr.arguments.flatMap((arg) => getDownstreamRefs(context, arg)).flatMap((ref2) => getUpstreamReactVariables(context, ref2.resolved));
        if (argsUpstreamVariables.some((variable) => isState(variable))) {
          context.report({
            node: callExpr,
            messageId: messages4.avoidPassingLiveStateToParent
          });
        }
      });
    }
  })
};

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/no-initialize-state.js
init_esm_shims();
var name5 = "no-initialize-state";
var messages5 = {
  avoidInitializingState: "avoidInitializingState"
};
var rule5 = {
  meta: {
    type: "suggestion",
    docs: {
      description: "Disallow initializing state in an effect."
    },
    schema: [],
    messages: {
      [messages5.avoidInitializingState]: 'Avoid initializing state in an effect. Instead, pass "{{state}}"\'s initial value to its `useState`.'
    }
  },
  create: (context) => ({
    CallExpression: (node) => {
      if (!isUseEffect(node)) return;
      const effectFnRefs = getEffectFnRefs(context, node);
      const depsRefs = getDependenciesRefs(context, node);
      if (!effectFnRefs || !depsRefs) return;
      if (depsRefs.length > 0) return;
      effectFnRefs.filter(isFnRef).filter((ref) => isDirectCall(ref.identifier)).filter((ref) => isStateSetter(context, ref)).forEach((ref) => {
        const useStateNode = getUseStateNode(context, ref);
        const stateName = (useStateNode.id.elements[0] ?? useStateNode.id.elements[1])?.name;
        context.report({
          node: getCallExpr(ref),
          messageId: messages5.avoidInitializingState,
          data: { state: stateName }
        });
      });
    }
  })
};

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/no-chain-state-updates.js
init_esm_shims();
var name6 = "no-chain-state-updates";
var messages6 = {
  avoidChainingStateUpdates: "avoidChainingStateUpdates"
};
var rule6 = {
  meta: {
    type: "suggestion",
    docs: {
      description: "Disallow chaining state changes in an effect.",
      url: "https://react.dev/learn/you-might-not-need-an-effect#chains-of-computations"
    },
    schema: [],
    messages: {
      [messages6.avoidChainingStateUpdates]: "Avoid chaining state changes. When possible, update all relevant state simultaneously."
    }
  },
  create: (context) => ({
    CallExpression: (node) => {
      if (!isUseEffect(node)) return;
      const effectFnRefs = getEffectFnRefs(context, node);
      const depsRefs = getDependenciesRefs(context, node);
      if (!effectFnRefs || !depsRefs) return;
      const isAllDepsInternal = depsRefs.flatMap((ref) => getUpstreamReactVariables(context, ref.resolved)).notEmptyEvery(
        (variable) => isState(variable) || isProp(variable) && !isHOCProp(variable)
      );
      effectFnRefs.filter(isFnRef).filter((ref) => isDirectCall(ref.identifier)).filter((ref) => isStateSetter(context, ref)).forEach((ref) => {
        const callExpr = getCallExpr(ref);
        const argsUpstreamVariables = callExpr.arguments.flatMap((arg) => getDownstreamRefs(context, arg)).flatMap((ref2) => getUpstreamReactVariables(context, ref2.resolved));
        const isAllArgsInternal = argsUpstreamVariables.notEmptyEvery(
          (variable) => isState(variable) || isProp(variable) && !isHOCProp(variable)
        );
        const isSomeArgsExternal = argsUpstreamVariables.some(
          (variable) => !isState(variable) && !isProp(variable) || isHOCProp(variable)
        );
        if (!isAllArgsInternal && !isSomeArgsExternal && isAllDepsInternal) {
          context.report({
            node: callExpr,
            messageId: messages6.avoidChainingStateUpdates
          });
        }
      });
    }
  })
};

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/no-derived-state.js
init_esm_shims();
var name7 = "no-derived-state";
var messages7 = {
  avoidDerivedState: "avoidDerivedState"
};
var rule7 = {
  meta: {
    type: "suggestion",
    docs: {
      description: "Disallow storing derived state in an effect.",
      url: "https://react.dev/learn/you-might-not-need-an-effect#updating-state-based-on-props-or-state"
    },
    schema: [],
    messages: {
      [messages7.avoidDerivedState]: 'Avoid storing derived state. Compute "{{state}}" directly during render, optionally with `useMemo` if it\'s expensive.'
    }
  },
  create: (context) => ({
    CallExpression: (node) => {
      if (!isUseEffect(node)) return;
      const effectFnRefs = getEffectFnRefs(context, node);
      const depsRefs = getDependenciesRefs(context, node);
      if (!effectFnRefs || !depsRefs) return;
      effectFnRefs.filter(isFnRef).filter((ref) => isDirectCall(ref.identifier)).filter((ref) => isStateSetter(context, ref)).forEach((ref) => {
        const callExpr = getCallExpr(ref);
        const useStateNode = getUseStateNode(context, ref);
        const stateName = (useStateNode.id.elements[0] ?? useStateNode.id.elements[1])?.name;
        const argsUpstreamVars = callExpr.arguments.flatMap((arg) => getDownstreamRefs(context, arg)).flatMap((ref2) => getUpstreamReactVariables(context, ref2.resolved));
        const depsUpstreamVars = depsRefs.flatMap(
          (ref2) => getUpstreamReactVariables(context, ref2.resolved)
        );
        const isAllArgsInternal = argsUpstreamVars.notEmptyEvery(
          (variable) => isState(variable) || isProp(variable) && !isHOCProp(variable)
        );
        const isAllArgsInDeps = argsUpstreamVars.notEmptyEvery(
          (argVar) => depsUpstreamVars.some((depVar) => argVar.name === depVar.name)
        );
        if (isAllArgsInternal || // In this case the derived state will always be in sync,
        // thus it could be computed directly during render
        isAllArgsInDeps && countCalls(ref) === 1) {
          context.report({
            node: callExpr,
            messageId: messages7.avoidDerivedState,
            data: { state: stateName }
          });
        }
      });
    }
  })
};

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/no-pass-data-to-parent.js
init_esm_shims();
var name8 = "no-pass-data-to-parent";
var messages8 = {
  avoidPassingDataToParent: "avoidPassingDataToParent"
};
var rule8 = {
  meta: {
    type: "suggestion",
    docs: {
      description: "Disallow passing data to parents in an effect.",
      url: "https://react.dev/learn/you-might-not-need-an-effect#passing-data-to-the-parent"
    },
    schema: [],
    messages: {
      [messages8.avoidPassingDataToParent]: "Avoid passing data to parents in an effect. Instead, let the parent fetch the data itself and pass it down to the child as a prop."
    }
  },
  create: (context) => ({
    CallExpression: (node) => {
      if (!isUseEffect(node)) return;
      const effectFnRefs = getEffectFnRefs(context, node);
      const depsRefs = getDependenciesRefs(context, node);
      if (!effectFnRefs || !depsRefs) return;
      effectFnRefs.filter(isFnRef).filter((ref) => isDirectCall(ref.identifier)).filter(
        (ref) => isPropCallback(context, ref) && !isHOCProp(ref.resolved)
      ).forEach((ref) => {
        const callExpr = getCallExpr(ref);
        const argsUpstreamVariables = callExpr.arguments.flatMap((arg) => getDownstreamRefs(context, arg)).flatMap((ref2) => getUpstreamReactVariables(context, ref2.resolved));
        if (callExpr.arguments.some((arg) => arg.type === "Literal") || argsUpstreamVariables.some(
          (variable) => !isState(variable) && !isRef(variable)
        )) {
          context.report({
            node: callExpr,
            messageId: messages8.avoidPassingDataToParent
          });
        }
      });
    }
  })
};

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/no-manage-parent.js
init_esm_shims();
var name9 = "no-manage-parent";
var messages9 = {
  avoidManagingParent: "avoidManagingParent"
};
var rule9 = {
  meta: {
    type: "problem",
    docs: {
      description: "Disallow effects that only use props."
    },
    schema: [],
    messages: {
      [messages9.avoidManagingParent]: "This effect only uses props. Consider lifting the logic up to the parent."
    }
  },
  create: (context) => ({
    CallExpression: (node) => {
      if (!isUseEffect(node)) return;
      const effectFnRefs = getEffectFnRefs(context, node);
      const depsRefs = getDependenciesRefs(context, node);
      if (!effectFnRefs || !depsRefs) return;
      if (effectFnRefs.length === 0) return;
      if (effectFnRefs.concat(depsRefs).every((ref) => isProp(ref.resolved) && !isHOCProp(ref.resolved))) {
        context.report({
          node,
          messageId: messages9.avoidManagingParent
        });
      }
    }
  })
};

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/index.js
import globals2 from "globals";

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/util/javascript.js
init_esm_shims();
Array.prototype.notEmptyEvery = function(predicate) {
  return this.length > 0 && this.every(predicate);
};

// node_modules/eslint-plugin-react-you-might-not-need-an-effect/src/index.js
var plugin = {
  meta: {
    name: "react-you-might-not-need-an-effect"
  },
  configs: {},
  rules: {
    [name]: rule,
    [name2]: rule2,
    [name3]: rule3,
    [name4]: rule4,
    [name8]: rule8,
    [name9]: rule9,
    [name5]: rule5,
    [name6]: rule6,
    [name7]: rule7
  }
};
var recommendedRules = Object.keys(plugin.rules).reduce((acc, ruleName) => {
  acc[plugin.meta.name + "/" + ruleName] = "warn";
  return acc;
}, {});
var languageOptions = {
  globals: {
    // NOTE: Required so we can resolve global references to their upstream global variables
    ...globals2.browser
  },
  parserOptions: {
    ecmaFeatures: {
      jsx: true
    }
  }
};
Object.assign(plugin.configs, {
  // flat config format
  recommended: {
    files: ["**/*.{js,jsx,mjs,cjs,ts,tsx,mts,cts}"],
    plugins: {
      // Object.assign above so we can reference `plugin` here
      [plugin.meta.name]: plugin
    },
    rules: recommendedRules,
    languageOptions
  },
  "legacy-recommended": {
    plugins: [plugin.meta.name],
    rules: recommendedRules,
    ...languageOptions
  }
});
var src_default = plugin;

// src/eslint/configs/react.ts
import { isPackageListedSync } from "local-pkg";
var nextJsPackages = ["next"];
var vitePackages = ["vite"];
async function react() {
  const isUsingNext = nextJsPackages.some(
    (index) => isPackageListedSync(index)
  );
  const isUsingVite = vitePackages.some((index) => isPackageListedSync(index));
  const nextjsConfig = [];
  if (isUsingNext) {
    const nextPlugin = await import("@next/eslint-plugin-next").then(
      (d) => d.default
    );
    nextjsConfig.push(
      {
        name: "solvro/next/setup",
        plugins: {
          "@next/next": nextPlugin
        },
        rules: nextPlugin.configs.recommended.rules
      },
      {
        files: [
          "**/app/**/{page,loading,layout,template,error,not-found,unauthorized,forbidden,default,robots,sitemap}.{js,jsx,ts,tsx}",
          "**/pages/**/*.{js,jsx,ts,tsx}"
        ],
        name: "solvro/next/pages",
        rules: {
          "import/no-default-export": "off"
        }
      }
    );
  }
  const viteConfig = [];
  if (isUsingVite) {
    viteConfig.push(pluginReactRefresh.configs.vite);
  }
  return [
    {
      name: "solvro/react/setup",
      plugins: {
        react: pluginReact,
        "react-hooks": pluginReactHooks
      }
    },
    ...nextjsConfig,
    ...viteConfig,
    {
      files: ["**/*.{js,jsx,mjs,cjs,ts,tsx}"],
      languageOptions: {
        parserOptions: {
          ecmaFeatures: {
            jsx: true
          }
        },
        sourceType: "module"
      },
      settings: {
        react: {
          version: "detect"
        }
      },
      name: "solvro/react/rules",
      rules: {
        ...pluginReact.configs.flat.recommended.rules,
        ...pluginReact.configs.flat["jsx-runtime"].rules,
        "react/no-danger": "warn",
        "react/jsx-no-leaked-render": "warn",
        // recommended rules react-hooks
        "react-hooks/exhaustive-deps": "warn",
        "react-hooks/rules-of-hooks": "error",
        "react/jsx-no-useless-fragment": "error",
        "react/function-component-definition": [
          "error",
          {
            unnamedComponents: "arrow-function",
            namedComponents: "function-declaration"
          }
        ],
        "react/hook-use-state": [
          "error",
          {
            allowDestructuredState: true
          }
        ],
        "react/no-array-index-key": "warn"
      }
    },
    ...pluginQuery.configs["flat/recommended"],
    src_default.configs.recommended,
    {
      name: "solvro/react/disables",
      files: ["**/components/ui/*.{jsx,tsx}"],
      rules: {
        "react/prop-types": "off",
        "no-shadow": "off",
        "@typescript-eslint/no-shadow": "off",
        "@typescript-eslint/restrict-template-expressions": "off",
        "unicorn/no-document-cookie": "off",
        "@typescript-eslint/no-redeclare": "off",
        "@typescript-eslint/no-deprecated": "off"
      }
    }
  ];
}

// src/eslint/presets/react.ts
var reactPreset = async () => [
  ...a11y(),
  ...unicorn(),
  ...typescriptStrict(),
  ...imports({ forbidDefaultExport: true }),
  ...await react()
];
export {
  reactPreset
};
/*! Bundled license information:

eslint-utils/index.mjs:
  (*! @author Toru Nagashima <https://github.com/mysticatea> *)
*/
//# sourceMappingURL=react-PWJWWBLW.js.map